# コマンドラインの使い方

## はじめに

通常、パソコンを操作する際はファイルをマウスでクリックして選択、ダブルクリックで対応するアプリケーションで開いて修正して保存、などとしていることだろう。また、スマホやタブレットは指でタッチして様々な操作を行うであろう。この際、アイコンやボタンなど、操作対象がグラフィカルに表現されたものを、マウスやタッチで操作するインタフェースを **グラフィカルユーザインタフェース(Graphical User Interface, GUI)** と呼ぶ。

一方、主にキーボードからコマンドを入力してコンピュータを操作する方法もある。こちらは命令(コマンド)を一行(ライン)ずつ受け付け、解釈して実行することから **コマンドラインインタフェース(Command-line Interface, CLI)**　と呼ばれる。最初からGUIツールとして作られているWordやPowerPoint等と異なり、Gitはコマンドラインツールとして作られている。GitにはGit Guiや、SourceTreeなどのGUIツールも用意されているが、これはCLIにGUIの「皮」をかぶせたものだ。Gitを「ただ使う」だけであればGUIツールを使えばよいが、本講義の目的はGitを使うことではなく、Gitというバージョン管理ツールを理解することだ。また、GUIツールを使っていて何かトラブルが起きた場合、それがコマンドに起因するものなのか、GUIの「皮」に起因するものなのかを切り分けなければならず、そのためにはコマンドライン操作を理解していなければならない。そこで、まずはコマンドライン操作について学ぶ。

なお、コマンドライン操作において最も注目して欲しいのはエラーへの対応だ。GUIではそもそも「許されない操作」ができないように設計されていることが多いが、コマンドラインでは頻繫に「許されない操作」をしてしまい、「それはできないよ」というメッセージが表示されることだろう。これを **エラーメッセージ(Error Message)** と呼ぶ。エラーの多くは平易な英語で書いてあるので、ちゃんと読めば何が起きたか、そして次に何をすれば良いかがわかるはずだ。

## Unixコマンド

映画などでハッカーが何やら黒い画面を見ながらキーボードをものすごい勢いで叩いているのを見たことがあるだろう。この「黒い画面」はターミナル[^terminal]と呼ばれ、ユーザからの指示をコンピュータに入力するためのものだ。Gitはコマンドラインツールであるから、まずはコマンドラインの使い方に慣れなければならない。コマンドラインを入力するのはこのターミナルという黒い画面であるから、Gitを使うためにはこの「黒い画面」と友達にならなければならない。ターミナルへの命令はコマンドを通じて行われるが、このコマンドはオペレーティング・システムの種類によって異なる。GitはLinuxの開発のために作られた経緯があるため、Linux上で動作することを前提に作られた。LinuxはUnixを参考にして作られたため、Unixの直系の子孫ではないが、操作やコマンドが似ている。Unixは極めて古いOSであり、macOSもUnixの子孫である。Unixの子孫や、Unixと操作が似ているOSをまとめてUnix系システムと呼ぶ。Unix系システムでは、Unixコマンドと呼ばれるコマンド群を用いて操作する。以下では、Gitの操作に最低限必要なUnixコマンドについて説明する。ターミナルはWindowsのGit Bashを想定するが、WSL2のUbuntuやMacのターミナルでも同様である。

[^terminal]: より正確に言えばターミナル(端末)エミュレータのこと。もともと大きなホストコンピュータに、たくさんの端末がぶら下がっており、複数の人が一つのマシンに命令を入力していた。この「端末」をエミュレートしたものが端末エミュレータである。

### シェル

あまり意識していないだろうが、普段使っているパソコンやスマホ、タブレットには **オペレーティングシステム (Operating System, OS)** が搭載されている。Windows 10やmacOS、iOSやAndroidなどがOSだ。OSはハードウェアとソフトウェアの仲立ちをするのが役目だ。例えば、ストレージがハードディスクなのかSSDかによってその制御方法は全くことなるが、OSを介して見れば、どちらも同じファイルシステムに見える。そういう意味でOSはストレージを抽象化している。

![shell](fig/shell.png)

さて、いまファイルを作りたいとしよう。OSがストレージを抽象化しているため、ユーザはOSに「ファイルを作ってください」と依頼する必要がある。この、ユーザとOSの仲立ちをするのが **シェル(shell)** と呼ばれるシステムだ。ユーザは、ターミナル(黒い画面)から、シェルに命令を入力する。するとシェルはそれをOSに届け、OSが実際に処理を行う、という階層構造になっている[^kernel]。OSはハードウェアを抽象化し、さらにその周りを殻のように覆っていることからシェルという名前がついたようだ。

[^kernel]: より正確に言えば、シェルはOSの一部であり、ハードウェアを抽象化しているのはカーネル(kernel)と呼ばれるプログラムであるが、ここではOSとカーネルの区別はしないことにする。

シェルには、グラフィカルなシェルと、コマンドラインシェルがある。Windowsなどではグラフィカルなシェルが用意されており、マウスでファイルの移動をすることができる。一方、ターミナル上でコマンドを入力することで命令を実行するのがコマンドラインシェルである。以下では、コマンドラインシェルのことを単に「シェル」と呼ぶことにする。

### ディレクトリとパス

WindowsやMacでは、複数のファイルをまとめるものをフォルダと呼ぶが、Unix系システムでは　**ディレクトリ(directory)** と呼ぶ。

この命令が実行されるディレクトリ、すなわち「いま自分がいるディレクトリ」をカレントディレクトリ、もしくはワーキングディレクトリと呼ぶ。特に、ターミナルを開いた直後のカレントディレクトリを **ホームディレクトリ(Home directory)** と呼ぶ。

TODO: 相対パスと絶対パスの説明

### ややこしいファイル操作をしたい時

これからコマンドラインでのファイル操作について説明をするが、慣れないと操作ミスによる事故が起きやすい。自信がないい場合は使い慣れたグラフィカルなシェルで操作すると良いだろう。例えばWindowsのGit Bashであれば、

```sh
explorer .
```

を実行すると、カレントディレクトリをエクスプローラーで開くことができる(一つ空白をかえてピリオドを入力するのを忘れないこと)。

Macであれば

```sh
open .
```

によりカレントディレクトリをファインダーで開くことができる。あとはマウスでコピーや移動、削除などを実行すれば良い。

### コマンドプロンプト

多くのシェルでは、ユーザからの入力を待っている時に`$`が表示され、その隣でカーソルが点滅した状態となる。

```sh
$ 
```

これをコマンドプロンプト、あるいは単にプロンプトと呼び、コマンドが入力可能であることを表している。このプロンプトにコマンドを入力し、エンターキーを押すとその命令が処理される。コマンドに何か値を渡したいことがある。例えばファイルを削除するコマンドは`rm`だが、どのファイルを削除するか教えてやる必要がある。このように、コマンドに渡す値を **引数(ひきすう)** と呼ぶ。一方、コマンドの動作を変えるような引数を **オプション(option)** と呼び、`-`や`--`で始まることが多い。

### `ls`

カレントディレクトリに存在するディレクトリやファイルを表示するコマンドが`ls`だ[^ls]。

[^ls]: `list`の略だと思われる。

```sh
$ ls
```

上記は、`$`というコマンドプロンプトに、`ls`という文字を入力し、エンターキーを押す、という意味だ。ユーザが入力するのは`ls`(+エンターキー)だけであり、`$`は入力しないことに注意。

すると、例えば以下のような表示がされる。

```sh
$ ls
dir1/  dir2/  file1.txt  file2.txt
```

これは、カレントディレクトリに、`dir1`、`dir2`というディレクトリと、`file1.txt`、`file2.txt`というファイルがあるよ、という意味だ。ディレクトリは名前の右側に`/`がついていることが多いが、それはシェルの設定によるため、ついていない場合もある。

![ls](fig/ls.png)

`ls`に`-l`というオプションを渡すと、結果をリスト表示する。

```sh
$ ls -l
total 0
drwxr-xr-x 1 watanabe 197121 0  8月 17 21:03 dir1/
drwxr-xr-x 1 watanabe 197121 0  8月 17 20:32 dir2/
-rw-r--r-- 1 watanabe 197121 0  8月 17 20:33 file1.txt
-rw-r--r-- 1 watanabe 197121 0  8月 17 20:33 file2.txt
```

リスト表示では、ファイル名の他に、そのファイルの読み書きの許可、所有者、日付などが表示される。このように、「コマンドの直接の目的語」が引数、「コマンドの振る舞いを変える」のがオプションである。

引数としてカレントディレクトリの下にあるディレクトリ(サブディレクトリと言う)を指定することで、そのディレクトリの中身を表示することもできる。

```sh
$ ls dir1
file3.txt
```

存在しないファイルやディレクトリを指定すると、そんなファイルは知らないよ、というエラーが出る。

```sh
$ ls non-existing-dir
ls: cannot access 'non-existing-dir': No such file or directory
```

頭に`.`がついているファイルやディレクトリは隠しファイル、隠しディレクトリとなり、デフォルトでは表示されない。それを表示するには`ls -a`オプションを使う。

```sh
$ ls -a
./  ../  dir1/  dir2/  file1.txt  file2.txt
```

新たに表示された`.`と`..`は、それぞれカレントディレクトリと親ディレクトリの別名だ。どちらも良く使うので覚えておきたい。

### `cd`

カレントディレクトリを変更するコマンドが`cd`だ[^cd]。`cd`の後にディレクトリ名を指定すると、カレントディレクトリがそこに移動する。ダブルクリックでフォルダを開いた時には、そのフォルダの中身が自動的に表示された。しかし、コマンドラインインタフェースではそんな親切なことはしてくれない。カレントディレクトリをそのディレクトリに変更しておしまいである。中身を表示したければ`cd`した後に`ls`を実行しよう。

[^cd]: `change directory`の略だと思われる。

```sh
$ cd dir1
$ ls
file3.txt
```

![cd](fig/cd.png)

存在しないディレクトリに移動しようとしたら、エラーが出る。

```sh
$ cd non-exisiting-dir
bash: cd: non-exisiting-dir: No such file or directory
```

これは「`non-exisiting-dir`というディレクトリに`cd`しようとしたけど、そんなファイルもディレクトリも無いよ」というエラーだ。ファイルに対して`cd`しようとしてもエラーとなる。

```sh
$ cd file1.txt
bash: cd: file1.txt: Not a directory
```

これは「`file1.txt`はディレクトリではないので`cd`できないよ」というエラーだ。

`cd`コマンドを引数無しで実行すると、ホームディレクトリに戻る。重要なコマンドなので覚えておこう。

`..`は親ディレクトリを表すため、`cd ..`を実行するとカレントディレクトリが一つ上に移動する。

```sh
$ ls
dir1/  dir2/  file1.txt  file2.txt
$ cd dir1 # dir1に移る
$ ls
file3.txt
$ cd ..   #一つ上に戻る
$ ls
dir1/  dir2/  file1.txt  file2.txt
```

### `mkdir`

ディレクトリを作るには`mkdir`を使う[^mkdir]。引数にディレクトリ名を指定すると、カレントディレクトリにその名前のディレクトリを作る。

```sh
$ ls
dir1/  dir2/  file1.txt  file2.txt

$ mkdir dir3 # dir3を作成
$ ls
dir1/  dir2/  dir3/  file1.txt  file2.txt # dir3/が増えた
```

[^mkdir]: `make directory`の略であろう。

### `mv`


ファイルの移動や、ファイル名の変更には`mv`を使う[^mv]。グラフィカルなシェルではファイルの移動はマウスでドラッグするだけだが、コマンドラインでは「移動させたいファイル」「移動先」の二つの情報が必要だ。`mv`コマンドは、移動先がファイルかディレクトリか、移動先のファイルやディレクトリが存在するかしないかによって動作が異なるので注意したい。

[^mv]: `move`の略であろう。

TODO: 図解

#### `mv ファイル　ディレクトリ`

まず、一番使う頻度が高いと思われるのが、移動元がファイル、移動先がディレクトリの場合だ。ファイルがそのディレクトリに移動する。カレントディレクトリを表す`.`や、一つ上のディレクトリを表す`..`をよく使うので覚えておきたい。

```sh
mv test.txt dir1 # test.txtが、サブディレクトリのdir1に移動する
mv ../test.txt . # 一つ上にディレクトリにあるtest.txtを、カレントディレクトリに移動する
mv test.txt ..   # カレントディレクトリにあるtest.txtを、一つ上のディレクトリに移動する
```

ここでは全て相対パスで指定していることに注意。絶対パスでも指定できるが、少なくとも本講義では必要ないはず。

#### `mv ファイル　ファイル`

引数がどちらもファイル名、より正確には「移動先」として指定した名前のファイルやディレクトリが存在しない場合、「移動元」のファイル名をその「移動先」のファイル名にリネームする。

```sh
mv test1.txt test2.txt    # カレントディレクトリにあるtest1.txtをtest2.txtに変更
mv ../test1.txt test2.txt # 一つ上のディレクトリにあるtest1.txtを、test2.txtという名前に変更してカレントディレクトリに移動
mv dir1/test1.txt dir2/test2.txt # サブディレクトリdir1にあるtest1.txtを、dir2に移動し、しかも名前をtest2.txtに変更する
```

#### `mv ディレクトリ　ディレクトリ (移動先がある場合)`

移動元がディレクトリであり、移動先がディレクトリである場合、移動元のディレクトリを移動先のディレクトリの下に移動する。

```sh
mv dir1 dir2 # カレントディレクトリにあるdir1を、やはりカレントディレクトリにあるdir2に移動する
mv ../dir1 . # 上のディレクトリにあるdir1を、カレントディレクトリに移動する
mv dir1 ..   # カレントディレクトリにあるdir1を、一つ上のディレクトリに移動する
```

#### `mv ディレクトリ　ディレクトリ (移動先が無い場合)`

移動元がディレクトリであり、移動先に存在しない名前を指定した場合、ディレクトリをその場所に移動した上で、その名前にリネームする。なお、移動元のディレクトリの下にファイルやディレクトリがあった場合は、まとめて移動する。

```sh
mv dir1 dir2  # dir2が存在しない場合、dir1をdir2にリネームする
mv dir1 dir2/dir3 # dir2は存在するがdir2/dir3は存在しない場合、dir1をdir2の下に移動した上でdir3にリネームする
```

以上、まとめると`mv`は移動先が存在するディレクトリであればそこに移動、移動先が存在しないファイルやディレクトリであれば、移動元のファイルやディレクトリを移動した上でリネームする。

### `cp`

`mv`ではファイルを移動したが、元のファイルを残したまま複製したい場合は`cp`を使う[^cp]。移動元のファイルが消えない以外はほとんど`mv`と同じだ。

[^cp]: `copy`の略であろう。

```sh
cp test1.txt test2.txt # test1.txtをtest2.txtという名前で複製する
cp test1.txt dir      # test1.txtをdir1/test1.txtという名前で複製する
cp test1.txt test2.txt dir # 複数のファイルを一度にdirにコピーする
```

しかし、ディレクトリをコピーする場合は`-r`オプションが必要だ。

```sh
$ cp dir1 dir2  # コピー元がディレクトリである場合はエラーとなる
cp: -r not specified; omitting directory 'dir1'
$ cp -r dir1 dir2 # dir2が無い場合はその場所にコピー、ある場合はdir2の下にコピー
```

### `rm`,`rmdir`

ファイルを削除するには`rm`を使う。なお、中身が空ではないいディレクトリを削除する場合は`rm -r dir`と`-r`オプションを付ける必要があるが、再帰的に全てのファイル、サブディレクトリが削除されてしまうので、慣れないうちは実行しない方がよい。また、空のディレクトリを削除するために`rmdir`というコマンドがあるが、普段使うことは少ないので「`mkdir`の対になるコマンドが`rmdir`」とだけ覚えておけばよいだろう。

## Vim

Gitを使っていると、コミットやマージのメッセージ入力や、`rebase`の処理などで、コマンドライン上でエディタを使う必要が出てくる場合がある。多くの環境でGitのデフォルトエディタはVimだ。Vimは非常に強力なエディタであり、愛好者も多い(筆者もその一人である)のだが、普段使うエディタと使い勝手が異なるので戸惑うことも多いだろう。

ここでは、Vimの最低限の使い方だけ説明をする。

まずはコマンドラインで`vim`を実行すると、例えばこんな画面が出てくる。

```sh
$ vim
```

![vim](fig/vim.png)

Vimは「普通」のエディタと異なり、「モード」がある。起動直後は **ノーマルモード(Normal Mode)** となっている。ノーマルモードでは、Vimの終了や、カーソルの移動、行の削除や貼り付けなどの操作ができる。

ここで、キーボードの`i`を押すと、 **入力モード(Insert Mode)** になる。すると、画面の一番下に「-- 挿入 --」と表示される。なお、ターミナルの言語が英語だと`-- INSERT --`と表示されるなど、メッセージが英語になるが、ここでは日本語を前提に説明をする。この状態でキーを入力すると、入力したキーがそのまま挿入される。カーソルキー、エンターキーによる改行、バックスペースキーやデリートキーによる削除も可能なので、この状態で文章を編集する。

ファイルを保存したり、エディタを終了するためには「入力モード」から「ノーマルモード」に戻らなくてはならない。ノーマルモードに戻るにはエスケープキーを押す。すると画面下の「-- 挿入 --」が消える。

Vimを終了するには二つの方法がある。一つは「ノーマルモード」で`ZZ`(シフトを押しながら`Z`を二回入力)する方法だ。これは「保存して終了」という動作をする。しかし、何か編集をしており、ファイル名が未指定の場合には「E32: ファイル名がありません」と言われて終了ができない。

![vim_ZZ](fig/vim_ZZ.png)

ファイル名を指定するには、**コマンドモード (Command Mode)** に入る必要がある。コマンドモードに入るためには、`:`(コロン)を入力する。すると、画面下に`:`が現れ、そこにカーソルが移る。

![vim_command](fig/vim_command.png)

ここで`w`の後に空白をあけてファイル名を指定し、エンターキーを押すと、現在編集中の内容をそのファイル名で名前をつけて保存できる。

```vim
:w test.txt
```

上記を実行すると、「無名」とあったところにファイル名が表示される。

![vim_filename](fig/vim_filename.png)

この状態になったら、`ZZ`の入力で終了できる。

また、コマンドモードで、`q!`と入力すると、現在編集中の内容を破棄してそのまま終了できる。

慣れない人は、Vimの終了方法に戸惑いがちだ。もう一度終了方法をまとめておこう。

* もし入力モードであったら、エスケープキーを押してノーマルモードに移る。どのモードからでもエスケープキーを押せばノーマルモードになるので、現在のモードがわからなくてもとりあえずエスケープキーを押せばよい。
* 現在編集中の内容がファイル名を持っていて、編集内容を保存して終了したければそのまま`ZZ`(シフトキーを押しながら`Z`を二回)を入力する。
* 現在編集中の内容を破棄して終了したければ、`:`を押してコマンドモードとなり、`w!`を入力してエンターキーを押す(ノーマルモードで`:q!`と順番に入力してエンターキーを押せば良い)。

GitからVimが呼び出される場合は必ず名前があるファイルを渡されるはずなので、

* `i`を押してインサートモードにする
* 内容を編集する
* エスケープキーを押してノーマルモードに戻る
* `ZZ`でエディタを抜ける

という一連の操作を行えばよく、とりあえずコマンドモードを覚える必要ない。また、Vimにはもう一つ **ビジュアルモード(Visual Mode)** というモードがあり、こちらも使えると便利なのだが、ここでは触れない。

## 余談：OSの系譜とドラマ

WordやPowerPointなど、普段使うアプリケーションは、オペレーティング・システムの上で動作している。オペレーティング・システム(OS)は、基本ソフトとも呼ばれ、ハードウェアとアプリケーションの間で動作する。その存在を意識することは少ないが、PCやスマホ、タブレットなどのデバイスの使い勝手を大きく左右する重要なソフトウェアである。普段よく目にするOSは、PCならWindowsかmacOS、スマホならAndroidかiOSであろう。WindowsはMicrosoft、macOSやiOSはApple、AndroidはGoogleが開発している。OSは日々進化しており、どんどん新しい機能が追加されていく。その進化に乗り遅れたOSは市場から淘汰されてしまうため、その裏には様々なドラマがある。そのうちWindows 95とmacOSの話を紹介したい。

1980年代、MS-DOS、そしてWindows 3.1というOSにより大きなシェアを獲得したMicrosoftは、二つのOSの開発を進めていた。一つはコンシューマ向けの「使いやすい」OS、もう一つはサーバ向けの「信頼性の高い」OSだ。後者はWindows NTとして完成するが、その時の筆舌に尽くしがたい「デスマーチ」の様子が「闘うプログラマー」に記述があるので興味のある人は読んで見ると良いであろう。さて、もう一つの「家庭用」のOS開発プロジェクトは「カイロ」という名前で進められていたが、進捗が悪かった。そこで、「シカゴ」という別プロジェクトが走り出す。情報科学で博士号を取ったような人ばかりで構成された「カイロ」と、職人プログラマを寄せ集めたような「シカゴ」、どちらがMicrosoftの次世代OSを担うか、ビル・ゲイツの前で「裁判」が行われる。「カイロ」は400ページに渡る資料を用意し、いかに「シカゴ」がダメかを論じたのに対して、「シカゴ」チームはただ一枚のCD-ROMを取り出し、開発中のOSを実演してみせた。両方の言い分を聞いたビル・ゲイツは即座にカイロのキャンセルを決断。その時にCD-ROMに入っていたOSは、後に大ブームを巻き起こすことになるWindows 95のベータ版であった。負けた「カイロ」を率いていたリーダー、ジム・オールチンは、後にWindows Vistaの開発を率いることになり、そこにも面白いストーリーがあるのだが、ここでは割愛しよう。

macOS開発のドラマも面白い。1984年、Appleはグラフィックを重視するコンピュータ、Macintoshを発売する。MS-DOS等、他のOSがコマンドラインインタフェースを採用することがほとんどであった当時、マウスで直感的に操作できるグラフィカルなシェルを搭載したOSは画期的であり、GUIという概念の普及に大きく貢献した。OSは「System」と呼ばれ、ハードと一体で開発されていた。Systemは優れたOSであったが、長く開発が続けられるうちに設計が古くなり、不安定になっていった。Microsoftと同様に、1980年代後半から次世代OSの必要性を痛感していたAppleは「コープランド(copland)」というプロジェクトを立ち上げ、新しいOSの開発をすすめる。しかし、必要と思われる機能を際限なく仕様に追加していった結果、プロジェクトは収集がつかなくなり、AppleはOSの自社開発を断念、外部から調達することを決断する。次世代Mac OSの候補は二つ、かつてAppleで開発責任者を務めたジャン＝ルイ・ガセー独立し、設立したBe社が開発したBeOSと、Appleの創業者でありながら、自らが引き抜いたCEOにAppleを追い出されたスティーブ・ジョブズが設立したNeXT社が開発したOPENSTEPである。ガセーは勝利を確信していたフシがあり、プレゼンに力を入れなかったが、ジョブズは完璧なプレゼンを行い、結果、次世代OSの座を獲得したのはOPENSTEPとなり、ジョブズはAppleに返り咲く。ジョブズがAppleを去ったのは、ガセーによる密告が原因という話もあり、そのあたりの「ドラマ」も興味深い。

MicrosoftはしばらくWindows 95系列とWindows NT系列を両方開発していたが、両者はWindows XPにて統合され、Windows 95系列はWindows Meを最後に開発を終えた。MacのOSは、当初Macintosh搭載のSystemとしてスタートしたが、Mac OS 9を最後にOPENSTEP由来のMacOS Xに移行し、役目を終えた。中身は完全に変わったが、どちらも「Windows」「Mac」として開発、発売が続いている。OSはソフトウェアであり、ソフトウェアは人が開発するものである以上、人の数だけドラマがある。いまもどこかで次世代OSの開発が進められているのだろう。そこにはどんなドラマが待っているだろうか。

* 参考文献
    * [闘うプログラマー](https://www.amazon.co.jp/dp/4822247570)
    * [米マイクロソフト本社で目の当たりにしたビル・ゲイツの決断力](https://www.huffingtonpost.jp/satoshi-nakajima/bill-gates-microsoft_b_10351956.html)
    * [アップル薄氷の500日](https://www.amazon.co.jp/dp/4797306157)
