<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                <title></title>
    <style type="text/css">
      p {
        padding-left: 1em;
      }

      .markdown-body {
        box-sizing: border-box;
        min-width: 200px;
        max-width: 980px;
        margin: 0 auto;
        padding: 45px;
      }

      p.caption {
        display: none;
      }

      img {
        width: 100%
      }

      @media (max-width: 767px) {
        .markdown-body {
          padding: 15px;
        }
      }
    </style>
    <link rel="stylesheet" href="https://kaityo256.github.io/python_zero/github-markdown.css" type="text/css" />

    <meta name="viewport" content="width=device-width, initial-scale=1">

        <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
        <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
  </head>

  <body>
    <article class="markdown-body">
                        <h1 id="gitの仕組み">Gitの仕組み</h1>
<h2 id="はじめに">はじめに</h2>
<p>Gitで管理するプロジェクトには<code>.git</code>というディレクトリがあり、その中にGitの管理情報が入っている。その中には、全てのコミットや、いろんなバージョンのファイル、ブランチ、タグといった情報が格納されている。Gitを操作するにあたり、この中身がどうなっているかを理解する必要はないし、もし中身を覚えたとしても、操作方法は変わらないまま、内部実装だけ変更になる可能性もある。それでも、Gitの仕組み、特に様々な情報が<code>.git</code>にどのように格納されているかを知っておくのは二つの理由から有用だと考える。</p>
<p>一つ目の理由は、「物が動く仕組み」を知っておくことが教養だからだ。車を運転するのに、アクセルを踏めば進み、ブレーキを踏めば止まり、ハンドルを回せば曲がることを知っていれば十分だ。しかし、シリンダーにガソリンが噴射され、ピストンで圧縮したところで点火し、爆発する力でピストンが押される、という直線的な動きを作り、それを回転運動に変換してタイヤが回っている、ということくらいは(特に理工系の学生なら)ぼんやりとは知っておいて欲しい。さらに、その点火システム(イグニッションコイル)に電磁誘導が使われていると知れば、「なるほど、学校で習った電磁気の性質がこんなところに使われているのか」と思うことであろう。自分でゼロから作れるほど理解する必要はないが、物やツールをブラックボックスにせず、その中身をぼんやりとでも知っておくのは良いことだ。</p>
<p>もう一つの理由は、「機能は、なんらかの方法で実装されている」という感覚を持って欲しいためだ。我々がツールに求めるのは「機能」であるが、同じ機能であっても複数の実現手段がある。例えば、電子レンジとオーブンは、「どちらも食品を加熱する」という機能を持っているが、その実現方法は異なる。同様に、GitもSubversionはどちらもバージョン管理システムであり、どちらにもブランチやタグという概念があるが、その実装方法は全く異なる。Gitはツールである。ツールであるからには何らかの機能を提供している。その機能、例えばコミットによるスナップショットの保存や、ブランチの切り替えなどが、実際にはどのように実現されているかを見てみるのは無駄にはならないであろう。</p>
<p>以下では、Gitの実装、特に<code>.git</code>ディレクトリの中に何がどのように格納されているか紹介する。その詳細を覚える必要は全くない。しかし、「機能の実現には実装が伴う」ということ、また、Gitの実装が非常に素直であることを実感して欲しい。</p>
<h2 id="gitディレクトリの中身"><code>.git</code>ディレクトリの中身</h2>
<p>まず、<code>.git</code>の中身を見てみよう。適当なリポジトリで<code>ls .git</code>してみる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">ls</span> .git
<span class="ex">COMMIT_EDITMSG</span>  HEAD       branches/  description  index  logs/     packed-refs
<span class="ex">FETCH_HEAD</span>      ORIG_HEAD  config     hooks/       info/  objects/  refs/</code></pre></div>
<p>表示されるファイルはリポジトリの状態によって異なるが、概ね上記のようなファイルやディレクトリが含まれている。このうち、主なものを紹介する。</p>
<ul>
<li><code>HEAD</code> - カレントブランチ(HEAD)の情報を保存するファイル</li>
<li><code>index</code> - インデックスの情報を保存するファイル</li>
<li><code>config</code> - リモートブランチや上流ブランチ等の情報を保存するファイル</li>
<li><code>refs</code> - ブランチの情報を保存するディレクトリ</li>
<li><code>objects</code> - コミットなどのオブジェクトを保存するディレクトリ</li>
</ul>
<p>以下、これらの「中身」について触れてみよう。</p>
<h2 id="gitのオブジェクト">Gitのオブジェクト</h2>
<p>まずは、<code>.git/objects</code>の中身を見てみよう。ここにはGitが管理する「オブジェクト」が格納されている。Gitのオブジェクトには、以下の4種類がある。</p>
<div class="figure">
<img src="fig/objects.png" alt="objects" />
<p class="caption">objects</p>
</div>
<ul>
<li>blobオブジェクト： ファイルを圧縮したもの。ファイルシステムの「ファイル」に対応</li>
<li>treeオブジェクト： Blobオブジェクトや別のTreeオブジェクトを管理する。ファイルシステムの「ディレクトリ」に対応</li>
<li>コミットオブジェクト： Treeオブジェクトを包んだもの。コミットのスナップショットに対応するTreeオブジェクトに、親コミット、コミットメッセージなどを付加する</li>
<li>タグオブジェクト： 他のGitオブジェクトを包んだもの。ほとんどの場合はコミットオブジェクトを包むが、TagのメッセージやTagをつけた人の情報などを付加する</li>
</ul>
<p>この講義ではタグについては扱わないので、残りの三つ、blobオブジェクト、treeオブジェクト、コミットオブジェクトについて見てみよう。</p>
<h3 id="blobオブジェクト">blobオブジェクト</h3>
<div class="figure">
<img src="fig/blob.png" alt="blob" />
<p class="caption">blob</p>
</div>
<p>blob<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>オブジェクトは、ファイルを保存するためのオブジェクトだ。その実体は、ファイルに<code>blob</code>というテキストと、ファイルサイズをヘッダ情報として付加し、zlibで圧縮したものだ。</p>
<p>blobオブジェクトを実際に作ってみよう。適当なディレクトリで<code>git init</code>してから、適当なファイルを作る。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">mkdir</span> blob
<span class="bu">cd</span> blob
<span class="fu">git</span> init
<span class="bu">echo</span> -n <span class="st">&quot;Hello Git&quot;</span> <span class="op">&gt;</span> test.txt</code></pre></div>
<p>改行が含まれないように、echoに-nオプションをつけている。これをgit addすると対応するblobオブジェクトが作られる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">git</span> add test.txt</code></pre></div>
<p>この時点で、<code>e51ca0d0b8c5b6e02473228bbf876ba000932e96</code>というblobオブジェクトが作られた。見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -t e51ca0d0b8c5b6e02473228bbf876ba000932e96
<span class="ex">blob</span>

$ <span class="fu">git</span> cat-file -p e51ca0d0b8c5b6e02473228bbf876ba000932e96
<span class="ex">Hello</span> Git</code></pre></div>
<p><code>git cat-file</code>はオブジェクトのハッシュを指定して中身を見るためのコマンドだ。<code>-t</code>はそのオブジェクトのタイプを、<code>-p</code>は中身を表示する。<code>e51ca0d...</code>というオブジェクトはblobオブジェクトであり、中身は「Hello Git」というテキストファイルであることがわかる</p>
<p>この<code>e51ca0d...</code>というオブジェクトの実体は、<code>.git/objects</code>の中にファイルとして格納されている。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">ls</span> -1 .git/objects/*/*
<span class="ex">.git/objects/e5/1ca0d0b8c5b6e02473228bbf876ba000932e96</span></code></pre></div>
<p>Gitはオブジェクトのファイル名の頭二文字をディレクトリにして、残りをその下のファイルとして保存する。したがって、<code>e51ca0d...</code>というオブジェクトは、<code>.git/objects</code>以下の<code>e5</code>ディレクトリの下に、<code>1ca0d...</code>というファイル名で保存される。</p>
<p>このblobオブジェクトのファイル名は、対象となるファイルの頭にblob ファイルサイズをつけたもののSHA-1ハッシュ値だ。ハッシュ値とは、ハッシュ関数にデータを入力した時の出力であり、ハッシュ関数とは、任意の長さのデータから、(多くの場合)固定長の長さの値を得るための操作のことだ。SHAは「Secure Hash Algorithm」の略であり、SHA-1(シャーワン)はSHAシリーズのうちの一つである。</p>
<p>ハッシュとは、以下のような性質を持つものだ。</p>
<ul>
<li>任意の長さのデータを受け取り、固定の長さの出力(ハッシュ値)を返す</li>
<li>入力からハッシュ値を得るのは容易だが、あるハッシュ値を出力するような入力を探すのは極めて困難</li>
<li>入力が少しでも変化すると、ハッシュ値が大きく変化する</li>
</ul>
<p>特に二番目の性質を「強衝突耐性」と呼ぶ。例えばメッセージとハッシュ値を両方展開した時、もしメッセージが改変されていればハッシュ値が変わるから改竄がバレる。しかし、同じハッシュ値を持つ別の入力を作ることができれば、データを改竄してもバレない。</p>
<p>SHA-1の強衝突耐性は既に突破されているため、セキュリティ用途には向かないが、残りの二つの性質が便利であるため、GitではオブジェクトのIDとしてSHA-1ハッシュを用いている。SHA-1は任意の入力に対して160ビットの出力を返す。16進数は0からFまでの16種類の数値で表現され、1桁が4ビットであるから、160ビットを16進数表記すると40桁となる。これがGitのコミットハッシュが0からFまでの16種類の文字を使って40桁となる理由だ。Gitではハッシュ値を全桁指定する必要はなく、他と区別が付く長さだけ指定すれば良い。通常、先頭7桁も取れば十分なので、<code>git log --oneline</code>などでは7桁だけ表示される。</p>
<p>さて、このハッシュ値を実際に作ってみよう。そのためには、<code>test.txt</code>の冒頭に<code>blob 9\0</code>というヘッダを付けた内容のSHA-1ハッシュ値を求めればよい。なお、<code>blob 9\0</code>の<code>blob</code>はblobオブジェクトであること、<code>9</code>はファイルサイズ、<code>\0</code>はヌル文字と呼ばれ、ヘッダと中身の境界を表現している。SHA-1ハッシュを得るには<code>shasum</code>を用いる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="kw">{</span> <span class="bu">echo</span> -en <span class="st">&#39;blob 9\0&#39;</span><span class="kw">;</span><span class="fu">cat</span> test.txt<span class="kw">;}</span> <span class="kw">|</span> <span class="ex">shasum</span>
<span class="ex">e51ca0d0b8c5b6e02473228bbf876ba000932e96</span> *-</code></pre></div>
<p>確かに<code>e51ca0d</code>というコミットハッシュが得られた。なお、Gitにはヘッダを付けてハッシュを得るコマンド<code>git hash-object</code>が用意されている。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> hash-object test.txt
<span class="ex">e51ca0d0b8c5b6e02473228bbf876ba000932e96</span></code></pre></div>
<p>同じハッシュ値が得られた。<code>git cat-file</code>や<code>git hash-object</code>という、普段使わないが、普段使うコマンドの裏で実行されている低レベルなコマンドを <strong>配管コマンド(plumbing commands)</strong> と呼ぶ。一方、普段我々が使う<code>git add</code>や<code>git commit</code>などのコマンドを <strong>磁器コマンド (porcelain commands)</strong> と呼ぶ。これは、磁器とはトイレの便器のことで、Gitをトイレだと思った時、我々が普段使うコマンドが外に出ている便器、普段見ることのない低レベルなコマンドを下水などの配管にたとえたものだ。</p>
<p>細かいことはともかく、「Gitで良く出てくる英数字のIDはSHA-1ハッシュである」とだけ覚えておくと良い。</p>
<p>さて、ファイル名はSHA-1ハッシュであった。中身はファイルをヘッダ込みでzlibで圧縮したものだ。例えばPythonで実装するなこんな感じになる。</p>
<div class="sourceCode"><pre class="sourceCode py"><code class="sourceCode python"><span class="im">import</span> zlib
content <span class="op">=</span> <span class="st">&quot;Hello Git&quot;</span> <span class="co"># ファイルの中身</span>

<span class="co"># ヘッダ付与</span>
store <span class="op">=</span> <span class="ss">f&quot;blob </span><span class="sc">{</span><span class="bu">len</span>(content)<span class="sc">}</span><span class="ch">\0</span><span class="sc">{</span>content<span class="sc">}</span><span class="ss">&quot;</span>.encode(<span class="st">&quot;utf-8&quot;</span>)

data <span class="op">=</span> zlib.compress(store) <span class="co"># 圧縮</span>
<span class="bu">print</span>(<span class="bu">bytes</span>.<span class="bu">hex</span>(data))      <span class="co"># 中身の表示</span></code></pre></div>
<p><code>Hello Git</code>という中身を持つファイルに、<code>blob 9\0</code>というヘッダを付与して、<code>zlib.compress</code>で圧縮したバイト列を表示するスクリプトだ。実行してみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">python3</span> test.py
<span class="ex">789c4bcac94f52b064f048cdc9c95770cf2c01002b750531</span></code></pre></div>
<p>先ほど作成したblobオブジェクトの中身もダンプしてみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">od</span> -tx1 .git/objects/e5/1ca0d0b8c5b6e02473228bbf876ba000932e96
<span class="ex">0000000</span> 78 01 4b ca c9 4f 52 b0 64 f0 48 cd c9 c9 57 70
<span class="ex">0000020</span> cf 2c 01 00 2b 75 05 31
<span class="ex">0000030</span></code></pre></div>
<p>完全に一致していることがわかると思う。</p>
<p>まとめると、</p>
<ul>
<li>Gitのblobオブジェクトはファイルに対応している</li>
<li>blobオブジェクトは対象ファイルにヘッダを付与したものであり、ファイル名はSHA-1ハッシュ値、ファイルの中身はzlibで圧縮したもの</li>
</ul>
<p>である。以外に単純であることが実感できたであろうか？</p>
<h3 id="コミットオブジェクト">コミットオブジェクト</h3>
<p>コミットオブジェクトは、コミット、すなわちスナップショットを保存するためのものだ。先ほど、<code>git add</code>した状態で止めていたのを、コミットしてみよう。</p>
<p><code>sh $ git commit -m &quot;initial commit&quot; [main (root-commit) ca70291] initial commit  1 file changed, 1 insertion(+)  create mode 100644 test.txt</code></p>
<p>コミットハッシュ<code>ca70291</code>を持つコミットが作られた。これに対応するオブジェクトがコミットオブジェクトだ。いま、オブジェクトが何個できたか見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">ls</span> -1 .git/objects/*/*
<span class="ex">.git/objects/ca/70291031230dde40264d62b6e8d2424e2c9366</span>
<span class="ex">.git/objects/dd/1d7ee1e23a241a3597a0d0be5139a997fc29c8</span>
<span class="ex">.git/objects/e5/1ca0d0b8c5b6e02473228bbf876ba000932e96</span></code></pre></div>
<p><code>.git/objects</code>以下に3つオブジェクトができている。このうち、<code>e51ca0d</code>は<code>test.txt</code>に対応するblobオブジェクト、<code>ca70291</code>は今作ったコミットオブジェクト、もう一つの<code>dd1d7ee</code>は後述するtreeオブジェクトであり、コミットが保持するスナップショットを表現する 。blobオブジェクトやtreeオブジェクトは、同じ中身であれば同じハッシュ値を持つ。一方、コミットオブジェクトのハッシュはぶつかっては困るので、毎回異なるものになる。</p>
<p>さっき作ったコミットオブジェクト<code>ca70291</code>のタイプを見てみよう。。ちなみに、先ほど述べたように、ハッシュ値は他と区別が付けば40桁全てを指定する必要はない。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -t ca70291
<span class="ex">commit</span></code></pre></div>
<p>確かにコミットオブジェクトになっている。この表示から<code>ca70291</code>はコミットオブジェクトであることがわかる。コミットオブジェクトは、以下の情報をまとめたものだ。</p>
<ul>
<li>スナップショットを保存するtreeオブジェクト</li>
<li>親コミットのコミットハッシュ
<ul>
<li>root-commitなら親コミット情報なし</li>
<li>merge commitなら親コミット情報二つ</li>
</ul></li>
<li>コミットの作成者情報</li>
<li>コミットメッセージ</li>
</ul>
<p>中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -p ca70291
<span class="ex">tree</span> dd1d7ee1e23a241a3597a0d0be5139a997fc29c8
<span class="ex">author</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1632060650 +0900
<span class="ex">committer</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1632060650 +0900

<span class="ex">initial</span> commit</code></pre></div>
<p><code>dd1d7ee</code>というtreeオブジェクト、作成者、コミットメッセージを含んでいることがわかる。なお、これはroot commitなので、親コミットの情報は持っていない。適当に修正してコミットしてみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="bu">echo</span> <span class="st">&quot;Hello commit object&quot;</span> <span class="op">&gt;&gt;</span> test.txt
$ <span class="fu">git</span> commit -am <span class="st">&quot;update&quot;</span>
[<span class="ex">main</span> 1f620eb] update
 <span class="ex">1</span> file changed, 1 insertion(+), <span class="ex">1</span> deletion(-)</code></pre></div>
<p>新しく<code>1f620eb</code>というコミットができた。中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -p 1f620eb
<span class="ex">tree</span> 55e11d02569af14b5d29fe56fd44c1cc32c55e72
<span class="ex">parent</span> ca70291031230dde40264d62b6e8d2424e2c9366
<span class="ex">author</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1630738892  +0900
<span class="ex">committer</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1630738892 +0900


<span class="ex">update</span></code></pre></div>
<div class="figure">
<img src="fig/commit.png" alt="commit.png" />
<p class="caption">commit.png</p>
</div>
<p>スナップショットを表すtreeオブジェクトが<code>dd1d7ee</code>から<code>55e11d0</code>に更新され、新たに親コミットとして、先ほどの<code>ca70291</code>が保存されている。</p>
<p>マージにより作られたマージコミットの場合は、二つの親コミットの情報を含んでいる。いま、こんな歴史を持つリポジトリを考えよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> log --graph --pretty=oneline
<span class="ex">*</span>   f4baa057ce89467a2faced36229da02799c9e394 (HEAD -<span class="op">&gt;</span> main) <span class="ex">Merge</span> branch <span class="st">&#39;branch&#39;</span>
<span class="kw">|\</span>
<span class="kw">|</span> <span class="ex">*</span> 6aecd68aa423651edda9d22e20925314ff3e8386 (branch) <span class="ex">update</span>
<span class="ex">*</span> <span class="kw">|</span> <span class="ex">953cb6056e5f0437f0d4e102f232d8eb705f6428</span> adds test2.txt
<span class="kw">|</span><span class="ex">/</span>
<span class="ex">*</span> 6db4350c6ebd75338ac4bc2eb2a2924895a0c73b initial commit</code></pre></div>
<p>root commitである<code>6db4350</code>から<code>6aecd68</code>と<code>953cb60</code>が分岐し、マージされて<code>f4baa05</code>になっている。</p>
<div class="figure">
<img src="fig/merge.png" alt="merge.png" />
<p class="caption">merge.png</p>
</div>
<p>この最後のマージコミットf4baa05の中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -p f4baa05
<span class="ex">tree</span> 706a1741c1d94977ba496449d80ab848ca945e14
<span class="ex">parent</span> 953cb6056e5f0437f0d4e102f232d8eb705f6428
<span class="ex">parent</span> 6aecd68aa423651edda9d22e20925314ff3e8386
<span class="ex">author</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1630743012 +0900
<span class="ex">committer</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1630743012 +0900

<span class="ex">Merge</span> branch <span class="st">&#39;branch&#39;</span></code></pre></div>
<p>スナップショットを保存するtreeオブジェクト<code>706a174</code>の他に、二つの親コミット<code>953cb60</code>と<code>6aecd68</code>が保存されていることがわかる。</p>
<h3 id="treeオブジェクト">treeオブジェクト</h3>
<p>treeオブジェクトは、ディレクトリに対応するオブジェクトだ。先ほどのblobオブジェクトの作り方を見てわかるように、blobオブジェクトはファイル名を保存していない。blobオブジェクトとファイル名を対応させるのもtreeオブジェクトの役目だ。また、コミットオブジェクトが格納するのは、スナップショット全体を表現するtreeオブジェクトである。</p>
<p>treeオブジェクトがディレクトリに対応することを見るため、適当にディレクトリを含むリポジトリを作ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">mkdir</span> tree
<span class="bu">cd</span> tree
<span class="fu">git</span> init
<span class="fu">mkdir</span> dir1 dir2
<span class="bu">echo</span> <span class="st">&quot;file1&quot;</span> <span class="op">&gt;</span> dir1/file1.txt
<span class="bu">echo</span> <span class="st">&quot;file2&quot;</span> <span class="op">&gt;</span> dir2/file2.txt
<span class="bu">echo</span> <span class="st">&quot;README&quot;</span> <span class="op">&gt;</span> README.md
<span class="fu">git</span> add README.md dir1 dir2</code></pre></div>
<p>コミットしてみる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> commit -m <span class="st">&quot;initial commit&quot;</span>
[<span class="ex">main</span> (root-commit) <span class="ex">662458a</span>] initial commit
 <span class="ex">3</span> files changed, 3 insertions(+)
 <span class="ex">create</span> mode 100644 README.md
 <span class="ex">create</span> mode 100644 dir1/file1.txt
 <span class="ex">create</span> mode 100644 dir2/file2.txt</code></pre></div>
<p>これで、コミットオブジェクト(<code>662458a</code>)が作られた。中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -p 662458a
<span class="ex">tree</span> 193fea0500b331a7ccb536aa691d8eb7df8afd13
<span class="ex">author</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1630737694 +0900
<span class="ex">committer</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1630737694 +0900

<span class="ex">initial</span> commit</code></pre></div>
<p>treeオブジェクトとコミットメッセージ等の情報を含んでいることがわかる。root commitなので、親コミットの情報はない。同じ手順を踏めば、コミットハッシュは異なっても、同じtreeオブジェクトができているはずだ。treeオブジェクト<code>193fea0</code>は、このコミットのスナップショットを保存している。見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -p 193fea0
<span class="ex">100644</span> blob e845566c06f9bf557d35e8292c37cf05d97a9769    README.md
<span class="ex">040000</span> tree 0b9f291245f6c596fd30bee925fe94fe0cbadd60    dir1
<span class="ex">040000</span> tree 345699cffb47ac20257e0ce4cebcbfc4b2a7f9e3    dir2</code></pre></div>
<p>ファイル<code>README.md</code>に対応する<code>blob</code>オブジェクトと、ディレクトリ<code>dir1</code>、<code>dir2</code>に対応するtreeオブジェクトが含まれている。二つのtreeオブジェクトも見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -p 0b9f291
<span class="ex">100644</span> blob e2129701f1a4d54dc44f03c93bca0a2aec7c5449    file1.txt
$ <span class="fu">git</span> cat-file -p 345699c
<span class="ex">100644</span> blob 6c493ff740f9380390d5c9ddef4af18697ac9375    file2.txt</code></pre></div>
<p>ファイル構造とオブジェクトの構造を図示すると以下のようになる。</p>
<div class="figure">
<img src="fig/tree.png" alt="tree.png" />
<p class="caption">tree.png</p>
</div>
<p>さて、blobオブジェクトやtreeオブジェクトにはファイル名、ディレクトリ名は含まれておらず、treeオブジェクトは、自分が管理するオブジェクトと名前の対応を管理している。</p>
<p>また、blobオブジェクトのハッシュは、ファイルサイズと中身だけで決まり、ファイル名は関係ない。したがって、Gitは「同じ中身だけど、異なるファイル名」を、同じblobオブジェクトで管理する。これを確認してみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">mkdir</span> synonym
<span class="bu">cd</span> synonym
<span class="fu">git</span> init
<span class="bu">echo</span> <span class="st">&quot;Hello&quot;</span> <span class="op">&gt;</span> file1.txt
<span class="fu">cp</span> file1.txt file2.txt
<span class="fu">git</span> add file1.txt file2.txt</code></pre></div>
<p>これで、中身が同じファイル<code>file1.txt</code>、<code>file2.txt</code>がステージングされた。コミットしてみる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> commit -m <span class="st">&quot;initial commit&quot;</span>
[<span class="ex">main</span> (root-commit) <span class="ex">75470e6</span>] initial commit
 <span class="ex">2</span> files changed, 2 insertions(+)
 <span class="ex">create</span> mode 100644 file1.txt
 <span class="ex">create</span> mode 100644 file2.txt</code></pre></div>
<p>コミットオブジェクト<code>75470e6</code>ができたので、中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -p 75470e6
<span class="ex">tree</span> e79a5d99a8e5cd5da0260866b85df60052fd045e
<span class="ex">author</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1630745015 +0900
<span class="ex">committer</span> H. Watanabe <span class="op">&lt;</span>kaityo256@example.com<span class="op">&gt;</span> 1630745015 +0900

<span class="ex">initial</span> commit</code></pre></div>
<p>treeオブジェクト<code>e79a5d9</code>ができている。中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> cat-file -p e79a5d9
<span class="ex">100644</span> blob e965047ad7c57865823c7d992b1d046ea66edf78    file1.txt
<span class="ex">100644</span> blob e965047ad7c57865823c7d992b1d046ea66edf78    file2.txt</code></pre></div>
<p>全く同じblobオブジェクトに別名を与えていることがわかる。</p>
<h2 id="gitの参照">Gitの参照</h2>
<p>Gitオブジェクトの次は、Gitの参照を見てみよう。参照はブランチやタグなどで<code>.git/refs</code>以下に格納されている。</p>
<h3 id="headとブランチの実体">HEADとブランチの実体</h3>
<div class="figure">
<img src="fig/head.png" alt="head" />
<p class="caption">head</p>
</div>
<p>通常、GitではHEADがブランチを、ブランチがコミットを指している。<code>HEAD</code>の実体は<code>.git/HEAD</code>というファイルだ。ブランチは<code>git/refs</code>にブランチ名と同名のファイルとして保存されている。例えば<code>main</code>ブランチの実体は<code>.git/refs/heads/main</code>というファイルだ。この関係を見てみよう。</p>
<p>適当なディレクトリ<code>test</code>を作って、その中で<code>git init</code>する。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">mkdir</span> test
<span class="bu">cd</span> test
<span class="fu">git</span> init</code></pre></div>
<p>この時点で<code>.git</code>が作られ、その中に<code>HEAD</code>が作られた。ファイルの中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/HEAD
<span class="ex">ref</span>: refs/heads/main</code></pre></div>
<p>この<code>ref: refs/heads/main</code>は、「<code>HEAD</code>は今<code>refs/heads/main</code>を指しているよ」という意味だ。しかし、<code>git init</code>直後はまだこのファイルは存在しない。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/refs/heads/main
<span class="ex">cat</span>: .git/refs/heads/main: そのようなファイルやディレクトリはありません</code></pre></div>
<p>さて、適当なファイルを作って、<code>git add</code>、<code>git commit</code>してみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="bu">echo</span> <span class="st">&quot;Hello&quot;</span> <span class="op">&gt;</span> hello.txt
$ <span class="fu">git</span> add hello.txt
$ <span class="fu">git</span> commit -m <span class="st">&quot;initial commit&quot;</span>
[<span class="ex">main</span> (root-commit) <span class="ex">c950332</span>] initial commit
 <span class="ex">1</span> file changed, 1 insertion(+)
 <span class="ex">create</span> mode 100644 hello.txt</code></pre></div>
<p>初めて<code>git commit</code>した時点で、<code>main</code>ブランチの実体が作られる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/refs/heads/main
<span class="ex">c9503326279796b24be86bdf9beb01c1af2d2b95</span></code></pre></div>
<p><code>main</code>ブランチの実体である<code>main</code>というファイルには、コミットオブジェクトのハッシュが入っている。今回のケースでは、先ほど作られたコミットオブジェクト<code>c950332</code>が保存されている。このように、通常は<code>HEAD</code>はブランチのファイルの場所を指し、ブランチのファイルはコミットオブジェクトのハッシュを保存している。<code>git log</code>で見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> log --oneline
<span class="ex">c950332</span> (HEAD -<span class="op">&gt;</span> main) <span class="ex">initial</span> commit</code></pre></div>
<p><code>HEAD -&gt; main</code>と、<code>HEAD</code>が<code>main</code>を指していることが明示されている。</p>
<h3 id="detached-head状態">Detached HEAD状態</h3>
<p>さて、直接コミットハッシュを指定して<code>git checkout</code>してみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> checkout c950332
<span class="ex">Note</span>: switching to <span class="st">&#39;c950332&#39;</span>.

<span class="ex">You</span> are in <span class="st">&#39;detached HEAD&#39;</span> state. You can look around, make experimental
<span class="ex">changes</span> and commit them, and you can discard any commits you make in this
<span class="ex">state</span> without impacting any branches by switching back to a branch.

<span class="ex">If</span> you want to create a new branch to retain commits you create, you may
<span class="kw">do</span> <span class="ex">so</span> (now or later) <span class="ex">by</span> using -c with the switch command. Example:

  <span class="fu">git</span> switch -c <span class="op">&lt;</span>new-branch-name<span class="op">&gt;</span>

<span class="ex">Or</span> undo this operation with:

  <span class="fu">git</span> switch -

<span class="ex">Turn</span> off this advice by setting config variable advice.detachedHead to false

<span class="ex">HEAD</span> is now at c950332 initial commit</code></pre></div>
<p>これで、<code>HEAD</code>がブランチを介してではなく、直接コミットを指している状態、いわゆる頭が取れた(<code>detached HEAD</code>)状態になった。この状態で<code>git log</code>を見てみる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> log --oneline
<span class="ex">c950332</span> (HEAD, main) <span class="ex">initial</span> commit</code></pre></div>
<p>先ほどと異なり、<code>HEAD</code>と<code>main</code>の間の矢印が消えた。<code>HEAD</code>ファイルの中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/HEAD
<span class="ex">c9503326279796b24be86bdf9beb01c1af2d2b95</span></code></pre></div>
<p>先ほどは<code>ref: refs/heads/main</code>と、<code>main</code>ブランチの実体ファイルへのパスが格納されていたが、今は<code>HEAD</code>が直接コミットを指していることを反映して、そのコミットハッシュが保存されている。</p>
<div class="figure">
<img src="fig/detached_head.png" alt="detached_head" />
<p class="caption">detached_head</p>
</div>
<p><code>main</code>ブランチに戻ろう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> switch main
$ <span class="fu">cat</span> .git/HEAD
<span class="ex">ref</span>: refs/heads/main</code></pre></div>
<p><code>.git/HEAD</code>の中身がブランチへの参照に戻っている。</p>
<h3 id="ブランチの作成と削除">ブランチの作成と削除</h3>
<p><code>main</code>ブランチから、もう一つブランチを生やしてみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">git</span> switch -c branch</code></pre></div>
<p>これで、<code>branch</code>ブランチが作られ、<code>main</code>の指すコミットと同じコミットを指しているはずだ。まずは<code>git log</code>で見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> log --oneline
<span class="ex">c950332</span> (HEAD -<span class="op">&gt;</span> branch, main) <span class="ex">initial</span> commit</code></pre></div>
<p><code>HEAD</code>は<code>branch</code>を指し、<code>branch</code>も<code>main</code>も<code>c950332</code>を指している状態になっている。ファイルの中身も確認しよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/HEAD
<span class="ex">ref</span>: refs/heads/branch

$ <span class="fu">cat</span> .git/refs/heads/main
<span class="ex">c9503326279796b24be86bdf9beb01c1af2d2b95</span>

$ <span class="fu">cat</span> .git/refs/heads/branch
<span class="ex">c9503326279796b24be86bdf9beb01c1af2d2b95</span></code></pre></div>
<p><code>.git/refs/heads/main</code>と同じ内容の<code>.git/refs/heads/branch</code>が作成されている。</p>
<p>ここで、人為的に<code>.git/refs/heads/</code>にもう一つファイルを作ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cp</span> .git/refs/heads/main .git/refs/heads/branch2
$ <span class="fu">ls</span> .git/refs/heads
<span class="ex">branch</span>  branch2  main</code></pre></div>
<p><code>.git/refs/heads</code>内に、<code>branch2</code>というファイルが作成された。<code>git log</code>を見てみると、</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> log --oneline
<span class="ex">c950332</span> (HEAD -<span class="op">&gt;</span> branch, main, branch2) <span class="ex">initial</span> commit</code></pre></div>
<p><code>branch2</code>が増え、<code>main</code>や<code>branch</code>と同じコミットを指していることが表示された。すなわち、<code>git</code>は<code>git log</code>が叩かれた時、全てのブランチがどのコミットを指しているか調べていることがわある。また、ブランチの作成が、単にファイルのコピーで実装されていることもわかった。</p>
<p>作った<code>branch2</code>をgitを使って消してみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> branch -d branch2
<span class="ex">Deleted</span> branch branch2 (was c950332)<span class="ex">.</span>

$ <span class="fu">ls</span> .git/refs/heads
<span class="ex">branch</span>  main</code></pre></div>
<p>問題なく消せた。<code>.git/refs/heads</code>にあったブランチの実体も消えた。つまり、ブランチの削除は単にファイルの削除として実装されている。</p>
<h3 id="リモートブランチと上流ブランチ">リモートブランチと上流ブランチ</h3>
<p>リモートブランチも、普通にブランチと同じようにファイルで実装されている。まずは一つ上のディレクトリにリモートブランチ用のベアリポジトリを作ろう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">git</span> init --bare ../test.git</code></pre></div>
<p>ベアリポジトリは、<code>.git</code>の中身がそのままディレクトリに展開された内容になっている。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">tree</span> ../test.git
<span class="ex">../test.git</span>
├── <span class="ex">HEAD</span>
├── <span class="ex">branches</span>
├── <span class="ex">config</span>
├── <span class="ex">description</span>
├── <span class="ex">hooks</span>
│   ├── <span class="ex">applypatch-msg.sample</span>
│   ├── <span class="ex">commit-msg.sample</span>
│   ├── <span class="ex">fsmonitor-watchman.sample</span>
│   ├── <span class="ex">post-update.sample</span>
│   ├── <span class="ex">pre-applypatch.sample</span>
│   ├── <span class="ex">pre-commit.sample</span>
│   ├── <span class="ex">pre-merge-commit.sample</span>
│   ├── <span class="ex">pre-push.sample</span>
│   ├── <span class="ex">pre-rebase.sample</span>
│   ├── <span class="ex">pre-receive.sample</span>
│   ├── <span class="ex">prepare-commit-msg.sample</span>
│   └── <span class="ex">update.sample</span>
├── <span class="ex">info</span>
│   └── <span class="ex">exclude</span>
├── <span class="ex">objects</span>
│   ├── <span class="ex">info</span>
│   └── <span class="ex">pack</span>
└── <span class="ex">refs</span>
    ├── <span class="ex">heads</span>
    └── <span class="ex">tags</span>

<span class="ex">9</span> directories, 16 files</code></pre></div>
<p><code>git init</code>直後の<code>.git</code>ディレクトリと同じ中身であることがわかる。</p>
<p>さて、このリポジトリをリモートリポジトリ<code>origin</code>として登録し、上流ブランチを<code>origin/main</code>にして<code>push</code>しよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> remote add origin ../test.git
$ <span class="fu">git</span> push -u origin main
<span class="ex">Enumerating</span> objects: 3, done.
<span class="ex">Counting</span> objects: 100% (3/3), <span class="kw">done</span><span class="ex">.</span>
<span class="ex">Writing</span> objects: 100% (3/3), <span class="ex">227</span> bytes <span class="kw">|</span> <span class="ex">227.00</span> KiB/s, done.
<span class="ex">Total</span> 3 (delta 0), <span class="ex">reused</span> 0 (delta 0)
<span class="ex">To</span> ../test.git
 <span class="ex">*</span> [new branch]      main -<span class="op">&gt;</span> main
<span class="ex">Branch</span> <span class="st">&#39;main&#39;</span> set up to track remote branch <span class="st">&#39;main&#39;</span> from <span class="st">&#39;origin&#39;</span>.</code></pre></div>
<p>これで、<code>origin/main</code>ブランチが作成され、<code>main</code>の上流ブランチとして登録された。<code>git branch</code>で見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> branch -vva
  <span class="ex">branch</span>                a35d7e4 updates hello.txt
<span class="ex">*</span> main                c950332 [origin/main] initial commit
  <span class="ex">remotes/origin/main</span> c950332 initial commit</code></pre></div>
<p><code>remotes/origin/main</code>ブランチが作成され、<code>main</code>ブランチの上流が<code>origin/main</code>になっていることがわかる。さて、<code>main</code>ブランチの実体は<code>.git/refs/main</code>というファイルだった。同様に、<code>remotes/origin/main</code>の実体は、<code>.git/refs/remotes/origin/main</code>にある。ブランチの名前を(ディレクトリも含めて)そのまま<code>.git/ref</code>に展開したような形になっている。<code>.git/refs/remotes/origin/main</code>の中身は、単にコミットハッシュが記録されているだけだ。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/refs/remotes/origin/main
<span class="ex">c9503326279796b24be86bdf9beb01c1af2d2b95</span></code></pre></div>
<p>また、<code>main</code>の実体も同じコミットハッシュを指しているだけで、ここに上流ブランチの情報はない</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/refs/heads/main
<span class="ex">c9503326279796b24be86bdf9beb01c1af2d2b95</span></code></pre></div>
<p><code>main</code>の上流ブランチは、ブランチの実体ファイルではなく、<code>.git/config</code>というファイルに保存されている。中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/config
[<span class="ex">core</span>]
        <span class="ex">repositoryformatversion</span> = 0
        <span class="ex">filemode</span> = true
        <span class="ex">bare</span> = false
        <span class="ex">logallrefupdates</span> = true
[<span class="ex">remote</span> <span class="st">&quot;origin&quot;</span>]
        <span class="ex">url</span> = ../test.git
        <span class="ex">fetch</span> = +refs/heads/*:refs/remotes/origin/*
[<span class="ex">branch</span> <span class="st">&quot;main&quot;</span>]
        <span class="ex">remote</span> = origin
        <span class="ex">merge</span> = refs/heads/main</code></pre></div>
<p>このファイルの階層構造は<code>git config</code>でそのままたどることができる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> config branch.main.remote
<span class="ex">origin</span>

$ <span class="fu">git</span> config remote.origin.url
<span class="ex">url</span> = ../test.git</code></pre></div>
<p>また、<code>git log</code>は、リモートブランチも調べてくれる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> log --oneline
<span class="ex">c950332</span> (HEAD -<span class="op">&gt;</span> main, origin/main) <span class="ex">initial</span> commit</code></pre></div>
<p><code>origin/main</code>が、<code>main</code>と同じブランチを指していることがわかる。</p>
<p>もう一つリモートリポジトリを増やしてみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">git</span> init --bare ../test2.git
<span class="fu">git</span> remote add origin2 ../test2.git</code></pre></div>
<p>これで、<code>.git/config</code>には<code>origin2</code>の情報が追加される。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/config
[<span class="ex">core</span>]
        <span class="ex">repositoryformatversion</span> = 0
        <span class="ex">filemode</span> = true
        <span class="ex">bare</span> = false
        <span class="ex">logallrefupdates</span> = true
[<span class="ex">remote</span> <span class="st">&quot;origin&quot;</span>]
        <span class="ex">url</span> = ../test.git
        <span class="ex">fetch</span> = +refs/heads/*:refs/remotes/origin/*
[<span class="ex">branch</span> <span class="st">&quot;main&quot;</span>]
        <span class="ex">remote</span> = origin
        <span class="ex">merge</span> = refs/heads/main
[<span class="ex">remote</span> <span class="st">&quot;origin2&quot;</span>]
        <span class="ex">url</span> = ../test2.git
        <span class="ex">fetch</span> = +refs/heads/*:refs/remotes/origin2/*</code></pre></div>
<p>しかし、まだ<code>origin2</code>の実体は作られていません。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">tree</span> .git/refs/remotes
<span class="ex">.git/refs/remotes</span>
└── <span class="ex">origin</span>
    └── <span class="ex">main</span>

<span class="ex">1</span> directory, 1 file</code></pre></div>
<p><code>origin</code>の実体がディレクトリで、その下に<code>main</code>ファイルがあるが、<code>origin2</code>というディレクトリはまだ存在しないことがわかる。</p>
<p>ここで、<code>main</code>ブランチの上流ブランチを<code>origin2/main</code>にして<code>push</code>してみる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> push -u origin2
<span class="ex">Enumerating</span> objects: 3, done.
<span class="ex">Counting</span> objects: 100% (3/3), <span class="kw">done</span><span class="ex">.</span>
<span class="ex">Writing</span> objects: 100% (3/3), <span class="ex">227</span> bytes <span class="kw">|</span> <span class="ex">227.00</span> KiB/s, done.
<span class="ex">Total</span> 3 (delta 0), <span class="ex">reused</span> 0 (delta 0)
<span class="ex">To</span> ../test2.git
 <span class="ex">*</span> [new branch]      main -<span class="op">&gt;</span> main
<span class="ex">Branch</span> <span class="st">&#39;main&#39;</span> set up to track remote branch <span class="st">&#39;main&#39;</span> from <span class="st">&#39;origin2&#39;</span>.</code></pre></div>
<p>このタイミングで<code>origin2/main</code>の実体が作られる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="ex">tree</span> .git/refs/remotes
<span class="ex">.git/refs/remotes</span>
├── <span class="ex">origin</span>
│   └── <span class="ex">main</span>
└── <span class="ex">origin2</span>
    └── <span class="ex">main</span>

<span class="ex">2</span> directories, 2 files</code></pre></div>
<p>そして、<code>origin2/main</code>が<code>main</code>や<code>origin/main</code>と同じコミットハッシュを指す。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">cat</span> .git/refs/remotes/origin2/main
<span class="ex">c9503326279796b24be86bdf9beb01c1af2d2b95</span></code></pre></div>
<p>したがって、<code>git log</code>に<code>origin2/main</code>も表示されるようになる</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> log --oneline
<span class="ex">c950332</span> (HEAD -<span class="op">&gt;</span> main, origin2/main, origin/main) <span class="ex">initial</span> commit</code></pre></div>
<h2 id="インデックス">インデックス</h2>
<p>ワーキングツリーとリポジトリの間に「インデックス」を挟み、コミットの前にステージングを行うのがGitの特徴だ。このインデックスの実体は<code>.git/index</code>という一つのファイルだ。この中身もちょっと覗いてみよう。</p>
<h3 id="インデックスの実体と中身">インデックスの実体と中身</h3>
<p>適当なディレクトリを掘って、そこにファイルを作り、<code>git init</code>してみる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="fu">mkdir</span> index_test
<span class="bu">cd</span> index_test
<span class="bu">echo</span> <span class="st">&quot;My first file&quot;</span> <span class="op">&gt;</span> test.txt
<span class="fu">git</span> init</code></pre></div>
<p>さて、<code>git init</code>した直後は、まだ<code>index</code>は作られていない。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">ls</span> .git/index
<span class="ex">ls</span>: cannot access <span class="st">&#39;.git/index&#39;</span>: No such file or directory</code></pre></div>
<p>しかし、<code>git add</code>すると<code>index</code>が作られる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> add test.txt
$ <span class="fu">ls</span> .git/index
<span class="ex">.git/index</span></code></pre></div>
<p>また、<code>git add test.txt</code>したことで、<code>test.txt</code>に対応するblobオブジェクトも作られている。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">ls</span> -1 .git/objects/*/*
<span class="ex">.git/objects/36/3d8b784900d74b3159e8e93a651c0db42629ef</span></code></pre></div>
<p><code>git add</code>は、ファイルをインデックスに登録するコマンドであった。したがって、いま<code>test.txt</code>がインデックスに登録されたはずだ。インデックスの中身は、<code>git ls-files --stage</code>で見ることができる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> ls-files --stage
<span class="ex">100644</span> 363d8b784900d74b3159e8e93a651c0db42629ef 0    test.txt</code></pre></div>
<p>確かに<code>test.txt</code>というファイルに対応するblobオブジェクトができている。そのハッシュは<code>363d8b784900d74b3159e8e93a651c0db42629ef</code>であり、先ほど<code>.git/objects</code>に作成されたものだ。</p>
<p>つまり、<code>git add test.txt</code>をした時、Gitは</p>
<ul>
<li><code>test.txt</code>に対応するblobオブジェクトを作り、SHA-1ハッシュを計算してファイル名とする。</li>
<li>作られたオブジェクトは<code>.git/objects</code>に保存。ただし、ハッシュの上二文字をディレクトリとし、残りをファイル名として仕分けする</li>
<li><code>index</code>にそのblobオブジェクトと名前を登録する</li>
</ul>
<p>という作業をしている。</p>
<h3 id="ブランチ切り替えとインデックス">ブランチ切り替えとインデックス</h3>
<p>ブランチを切り替えると、インデックスがどうなるか見てみよう。</p>
<p>まずはブランチ<code>branch_a</code>を作り、そこに<code>file_a.txt</code>を追加、コミットする。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> switch -c branch_a
<span class="ex">Switched</span> to a new branch <span class="st">&#39;branch_a&#39;</span>
$ <span class="bu">echo</span> <span class="st">&quot;This is A&quot;</span> <span class="op">&gt;</span> file_a.txt
$ <span class="fu">git</span> add file_a.txt
$ <span class="fu">git</span> commit -m <span class="st">&quot;adds file_a.txt&quot;</span>
[<span class="ex">branch_a</span> 41e4b52] adds file_a.txt
 <span class="ex">1</span> file changed, 1 insertion(+)
 <span class="ex">create</span> mode 100644 file_a.txt</code></pre></div>
<p>これで、ワーキングツリーには<code>test.txt</code>と<code>file_a.txt</code>の二つのファイルが含まれるようになった。当然、インデックスにも同じファイルが登録されている。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> ls-files --stage
<span class="ex">100644</span> e32836f4cedd87510bfd2f145bc0696861fdb026 0    file_a.txt
<span class="ex">100644</span> 363d8b784900d74b3159e8e93a651c0db42629ef 0    test.txt</code></pre></div>
<p><code>file_a.txt</code>のblobオブジェクトが増えている。これが<code>file_a.txt</code>のハッシュであることを確認しておこう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> hash-object file_a.txt
<span class="ex">e32836f4cedd87510bfd2f145bc0696861fdb026</span></code></pre></div>
<p>この状態で、ブランチを切り替えてみよう。まずは<code>main</code>に戻る。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> switch main
<span class="ex">Switched</span> to branch <span class="st">&#39;main&#39;</span></code></pre></div>
<p>インデックスを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> ls-files --stage
<span class="ex">100644</span> 363d8b784900d74b3159e8e93a651c0db42629ef 0    test.txt</code></pre></div>
<p><code>main</code>ブランチには<code>test.txt</code>しかないので、インデックスにあるのも<code>test.txt</code>のblobオブジェクトだけだ。</p>
<p>新たなブランチ<code>branch_b</code>を作り、歴史を分岐させよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> switch -c branch_b
<span class="ex">Switched</span> to a new branch <span class="st">&#39;branch_b&#39;</span></code></pre></div>
<p>ファイル<code>file_b.txt</code>を追加し、コミットする。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="bu">echo</span> <span class="st">&quot;This is B&quot;</span> <span class="op">&gt;</span> file_b.txt
$ <span class="fu">git</span> add file_b.txt
$ <span class="fu">git</span> commit -m <span class="st">&quot;adds file_b.txt&quot;</span>
[<span class="ex">branch_b</span> 81085f2] adds file_b.txt
 <span class="ex">1</span> file changed, 1 insertion(+)
 <span class="ex">create</span> mode 100644 file_b.txt</code></pre></div>
<p><code>git add</code>の時点で<code>file_b.txt</code>に対応するblobオブジェクトが作られ、インデックスに登録される。インデックスの中身を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> ls-files --stage
<span class="ex">100644</span> 6a571f63d9d0bce7995b5c08d218370d7ea719a5 0    file_b.txt
<span class="ex">100644</span> 363d8b784900d74b3159e8e93a651c0db42629ef 0    test.txt</code></pre></div>
<p><code>test.txt</code>と<code>file_b.txt</code>が入っている。</p>
<p>この状態で、<code>branch_a</code>ブランチに切り替えて見よう。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> switch branch_a
<span class="ex">Switched</span> to branch <span class="st">&#39;branch_a&#39;</span></code></pre></div>
<p>ワーキングツリーのファイルが<code>test.txt</code>と<code>file_a.txt</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">ls</span>
<span class="ex">file_a.txt</span>  test.txt</code></pre></div>
<p>インデックスの中身も連動する。</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">git</span> ls-files --stage
<span class="ex">100644</span> e32836f4cedd87510bfd2f145bc0696861fdb026 0    file_a.txt
<span class="ex">100644</span> 363d8b784900d74b3159e8e93a651c0db42629ef 0    test.txt</code></pre></div>
<div class="figure">
<img src="https://github.com/kaityo256/zenn-content/raw/main/articles/inside_the_index/switch.png" alt="index" />
<p class="caption">index</p>
</div>
<p>つまり、ブランチ切り替えの際、ワーキングツリーだけでなく、インデックスも切り替えられている。</p>
<h2 id="まとめ">まとめ</h2>
<p>Gitのオブジェクト、ブランチ、そしてインデックスの実装について見てみた。Gitのオブジェクトは、ファイルがblobオブジェクトに、ディレクトリがtreeオブジェクトに対応し、コミットオブジェクトは、スナップショットを表すtreeオブジェクトと、親コミットのハッシュ、そしてコミットの作者やメッセージの情報をまとめたものだ。オブジェクトの名前はSHA-1ハッシュ値になっており、blobオブジェクトやtreeオブジェクトは中身からハッシュ値が決まるため、同じ内容なら同じハッシュ値となる。</p>
<p>ブランチはファイルとして実装され、ブランチの作成はファイルのコピー、削除はファイルの削除で実装されている。また、<code>origin/main</code>みたいなリモートブランチは、<code>origin</code>はディレクトリとして実装されている。上流ブランチなどの情報は<code>.git/config</code>にあり、<code>git config</code>で表示できる情報は、そのまま<code>.git/config</code>内のファイルの構造に対応している。</p>
<p>インデックスは<code>.git/index</code>というファイルが実体であり、その中身は「blobオブジェクトの目録」であった。ブランチを切り替えるとインデックスの中身も切り替わる。そしてワーキングツリーがきれいな状態の場合は、ワーキングツリーとインデックスの中身は一致している。</p>
<p>以上を見て、非常に「素直」に実装されていることがわかったと思う。よくわからないコミットハッシュや、<code>.git</code>ディレクトリの中身も、上記の知識を持ってから見てみると「なるほどな」とわかった気になるものだ。</p>
<p>上記のことを完全に理解する必要はない。しかし、自動車のボンネットを開けた時に、これがエンジンで、ここがバッテリーで、ということくらいはわかるであろう。同じくらいの解像度でGitが裏で何をやっているかが、ぼんやりと分かればそれでよい。</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>blobは<a href="https://docs.github.com/en/rest/reference/git#blobs">Binary Large OBjectsの略</a>らしい。<a href="#fnref1">↩</a></p></li>
</ol>
</div>
          </article>
  </body>

  </html>