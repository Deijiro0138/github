# Gitの仕組み

## はじめに

Gitで管理するプロジェクトには`.git`というディレクトリがあり、その中にGitの管理情報が入っている。その中には、全てのコミットや、いろんなバージョンのファイル、ブランチ、タグといった情報が格納されている。Gitを操作するにあたり、この中身がどうなっているかを理解する必要はないし、もし中身を覚えたとしても、操作方法は変わらないまま、内部実装だけ変更になる可能性もある。それでも、Gitの仕組み、特に様々な情報が`.git`にどのように格納されているかを知っておくのは二つの理由から有用だと考える。

一つ目の理由は、「物が動く仕組み」を知っておくことが教養だからだ。車を運転するのに、アクセルを踏めば進み、ブレーキを踏めば止まり、ハンドルを回せば曲がることを知っていれば十分だ。しかし、シリンダーにガソリンが噴射され、ピストンで圧縮したところで点火し、爆発する力でピストンが押される、という直線的な動きを作り、それを回転運動に変換してタイヤが回っている、ということくらいは(特に理工系の学生なら)ぼんやりとは知っておいて欲しい。さらに、その点火システム(イグニッションコイル)に電磁誘導が使われていると知れば、「なるほど、学校で習った電磁気の性質がこんなところに使われているのか」と思うことであろう。自分でゼロから作れるほど理解する必要はないが、物やツールをブラックボックスにせず、その中身をぼんやりとでも知っておくのは良いことだ。

もう一つの理由は、「機能は、なんらかの方法で実装されている」という感覚を持って欲しいためだ。我々がツールに求めるのは「機能」であるが、同じ機能であっても複数の実現手段がある。例えば、電子レンジとオーブンは、「どちらも食品を加熱する」という機能を持っているが、その実現方法は異なる。同様に、GitもSubversionはどちらもバージョン管理システムであり、どちらにもブランチやタグという概念があるが、その実装方法は全く異なる。Gitはツールである。ツールであるからには何らかの機能を提供している。その機能、例えばコミットによるスナップショットの保存や、ブランチの切り替えなどが、実際にはどのように実現されているかを見てみるのは無駄にはならないであろう。

以下では、Gitの実装、特に`.git`ディレクトリの中に何がどのように格納されているか紹介する。その詳細を覚える必要は全くない。しかし、「機能の実現には実装が伴う」ということ、また、Gitの実装が非常に素直であることを実感して欲しい。

## `.git`ディレクトリの中身

まず、`.git`の中身を見てみよう。適当なリポジトリで`ls .git`してみる。

```sh
$ ls .git
COMMIT_EDITMSG  HEAD       branches/  description  index  logs/     packed-refs
FETCH_HEAD      ORIG_HEAD  config     hooks/       info/  objects/  refs/
```

表示されるファイルはリポジトリの状態によって異なるが、概ね上記のようなファイルやディレクトリが含まれている。このうち、主なものを紹介する。

* `HEAD` - カレントブランチ(HEAD)の情報を保存するファイル
* `index` - インデックスの情報を保存するファイル
* `config` - リモートブランチや上流ブランチ等の情報を保存するファイル
* `refs` - ブランチの情報を保存するディレクトリ
* `objects` - コミットなどのオブジェクトを保存するディレクトリ

以下、これらの「中身」について触れてみよう。

## Gitのオブジェクト

まずは、`.git/objects`の中身を見てみよう。ここにはGitが管理する「オブジェクト」が格納されている。Gitのオブジェクトには、以下の4種類がある。

![objects](fig/objects.png)

* blobオブジェクト： ファイルを圧縮したもの。ファイルシステムの「ファイル」に対応
* treeオブジェクト： Blobオブジェクトや別のTreeオブジェクトを管理する。ファイルシステムの「ディレクトリ」に対応
* コミットオブジェクト： Treeオブジェクトを包んだもの。コミットのスナップショットに対応するTreeオブジェクトに、親コミット、コミットメッセージなどを付加する
* タグオブジェクト： 他のGitオブジェクトを包んだもの。ほとんどの場合はコミットオブジェクトを包むが、TagのメッセージやTagをつけた人の情報などを付加する

この講義ではタグについては扱わないので、残りの三つ、blobオブジェクト、treeオブジェクト、コミットオブジェクトについて見てみよう。

### blobオブジェクト

![blob](fig/blob.png)

blob[^blob]オブジェクトは、ファイルを保存するためのオブジェクトだ。その実体は、ファイルに`blob`というテキストと、ファイルサイズをヘッダ情報として付加し、zlibで圧縮したものだ。

[^blob]: blobは[Binary Large OBjectsの略](https://docs.github.com/en/rest/reference/git#blobs)らしい。

blobオブジェクトを実際に作ってみよう。適当なディレクトリで`git init`してから、適当なファイルを作る。

```sh
mkdir blob
cd blob
git init
echo -n "Hello Git" > test.txt
```

改行が含まれないように、echoに-nオプションをつけている。これをgit addすると対応するblobオブジェクトが作られる。

```sh
git add test.txt
```

この時点で、`e51ca0d0b8c5b6e02473228bbf876ba000932e96`というblobオブジェクトが作られた。見てみよう。

```sh
$ git cat-file -t e51ca0d0b8c5b6e02473228bbf876ba000932e96
blob

$ git cat-file -p e51ca0d0b8c5b6e02473228bbf876ba000932e96
Hello Git
```

`git cat-file`はオブジェクトのハッシュを指定して中身を見るためのコマンドだ。`-t`はそのオブジェクトのタイプを、`-p`は中身を表示する。`e51ca0d...`というオブジェクトはblobオブジェクトであり、中身は「Hello Git」というテキストファイルであることがわかる

この`e51ca0d...`というオブジェクトの実体は、`.git/objects`の中にファイルとして格納されている。

```sh
$ ls -1 .git/objects/*/*
.git/objects/e5/1ca0d0b8c5b6e02473228bbf876ba000932e96
```

Gitはオブジェクトのファイル名の頭二文字をディレクトリにして、残りをその下のファイルとして保存する。したがって、`e51ca0d...`というオブジェクトは、`.git/objects`以下の`e5`ディレクトリの下に、`1ca0d...`というファイル名で保存される。

このblobオブジェクトのファイル名は、対象となるファイルの頭にblob ファイルサイズ\0をつけたもののSHA-1ハッシュ値だ。ハッシュ値とは、ハッシュ関数にデータを入力した時の出力であり、ハッシュ関数とは、任意の長さのデータから、(多くの場合)固定長の長さの値を得るための操作のことだ。SHAは「Secure Hash Algorithm」の略であり、SHA-1(シャーワン)はSHAシリーズのうちの一つである。

ハッシュとは、以下のような性質を持つものだ。

* 任意の長さのデータを受け取り、固定の長さの出力(ハッシュ値)を返す
* 入力からハッシュ値を得るのは容易だが、あるハッシュ値を出力するような入力を探すのは極めて困難
* 入力が少しでも変化すると、ハッシュ値が大きく変化する

特に二番目の性質を「強衝突耐性」と呼ぶ。例えばメッセージとハッシュ値を両方展開した時、もしメッセージが改変されていればハッシュ値が変わるから改竄がバレる。しかし、同じハッシュ値を持つ別の入力を作ることができれば、データを改竄してもバレない。

SHA-1の強衝突耐性は既に突破されているため、セキュリティ用途には向かないが、残りの二つの性質が便利であるため、GitではオブジェクトのIDとしてSHA-1ハッシュを用いている。SHA-1は任意の入力に対して160ビットの出力を返す。16進数は0からFまでの16種類の数値で表現され、1桁が4ビットであるから、160ビットを16進数表記すると40桁となる。これがGitのコミットハッシュが0からFまでの16種類の文字を使って40桁となる理由だ。Gitではハッシュ値を全桁指定する必要はなく、他と区別が付く長さだけ指定すれば良い。通常、先頭7桁も取れば十分なので、`git log --oneline`などでは7桁だけ表示される。

さて、このハッシュ値を実際に作ってみよう。そのためには、`test.txt`の冒頭に`blob 9\0`というヘッダを付けた内容のSHA-1ハッシュ値を求めればよい。なお、`blob 9\0`の`blob`はblobオブジェクトであること、`9`はファイルサイズ、`\0`はヌル文字と呼ばれ、ヘッダと中身の境界を表現している。SHA-1ハッシュを得るには`shasum`を用いる。

```sh
$ { echo -en 'blob 9\0';cat test.txt;} | shasum
e51ca0d0b8c5b6e02473228bbf876ba000932e96 *-
```

確かに`e51ca0d`というコミットハッシュが得られた。なお、Gitにはヘッダを付けてハッシュを得るコマンド`git hash-object`が用意されている。

```sh
$ git hash-object test.txt
e51ca0d0b8c5b6e02473228bbf876ba000932e96
```

同じハッシュ値が得られた。`git cat-file`や`git hash-object`という、普段使わないが、普段使うコマンドの裏で実行されている低レベルなコマンドを **配管コマンド(plumbing commands)** と呼ぶ。一方、普段我々が使う`git add`や`git commit`などのコマンドを **磁器コマンド (porcelain commands)** と呼ぶ。これは、磁器とはトイレの便器のことで、Gitをトイレだと思った時、我々が普段使うコマンドが外に出ている便器、普段見ることのない低レベルなコマンドを下水などの配管にたとえたものだ。

細かいことはともかく、「Gitで良く出てくる英数字のIDはSHA-1ハッシュである」とだけ覚えておくと良い。

さて、ファイル名はSHA-1ハッシュであった。中身はファイルをヘッダ込みでzlibで圧縮したものだ。例えばPythonで実装するなこんな感じになる。

```py
import zlib
content = "Hello Git" # ファイルの中身

# ヘッダ付与
store = f"blob {len(content)}\0{content}".encode("utf-8")

data = zlib.compress(store) # 圧縮
print(bytes.hex(data))      # 中身の表示
```

`Hello Git`という中身を持つファイルに、`blob 9\0`というヘッダを付与して、`zlib.compress`で圧縮したバイト列を表示するスクリプトだ。実行してみよう。

```sh
$ python3 test.py
789c4bcac94f52b064f048cdc9c95770cf2c01002b750531
```

先ほど作成したblobオブジェクトの中身もダンプしてみよう。

```sh
$ od -tx1 .git/objects/e5/1ca0d0b8c5b6e02473228bbf876ba000932e96
0000000 78 01 4b ca c9 4f 52 b0 64 f0 48 cd c9 c9 57 70
0000020 cf 2c 01 00 2b 75 05 31
0000030
```

完全に一致していることがわかると思う。

まとめると、

* Gitのblobオブジェクトはファイルに対応している
* blobオブジェクトは対象ファイルにヘッダを付与したものであり、ファイル名はSHA-1ハッシュ値、ファイルの中身はzlibで圧縮したもの

である。以外に単純であることが実感できたであろうか？

### コミットオブジェクト

コミットオブジェクトは、コミット、すなわちスナップショットを保存するためのものだ。スナップショットは、次に説明するtreeオブジェクトが保存しています。また、親コミットの情報も持っています。以上をまとめると、コミットオブジェクトは

## Gitの参照(refs)

### ブランチ

### タグ

## Gitのオブジェクト

まずは`objects`の中身の説明。

### blobオブジェクト

### コミットオブジェクト

### treeオブジェクト

### タグオブジェクト

## インデックス
