# バージョン管理とは

## なぜバージョン管理が必要か

ソフトウェア開発の歴史は古く、その開発手法も日進月歩である。ソフトウェア開発の歴史は、バグとの戦いの歴史でもあった。一人で開発していてもバグは入るが、大勢で開発を進めればより一層バグが入りやすくなり、ソフトウェア開発そのものよりも、バグの修正に時間を取られてしまう。また、多人数で開発をすすめると、誰がどこを修正したかがわかりにくくなる。例えば、複数の人が一つのWordファイルを回り持ちで修正し、「仕様書_佐藤修正_吉本追記.docx」というファイルと「仕様書_最終版_田中追記.docx」のどちらが最新版かわからなくなる、といったことが起きる。このような背景の中、バージョン管理システムは生まれた。

バージョン管理システムは、その名の通りファイルのバージョンを管理するためのツールである。いつ、誰が、どこを修正したかを記録し、必要とあれば古いバージョンを参照することができる。また、複数人が同じファイルを同時に編集してしまった場合に、その両方の変更を取り込む支援を行う。現在、バージョン管理システムを使わないソフトウェア開発は考えられず、プログラムの開発をともなう部署は、どのツールを使うかはともかく、なんらかのバージョン管理システムを採用しているものと思われる[^1]。

[^1]: もしバージョン管理システムを採用しておらず、日付やエクセルなどでバージョン管理をしている会社に入ってしまったらダッシュで逃げること。

本講義ではバージョン管理システムとしてGitを採用し、その使い方を学ぶが、その前にソフトウェア開発とはどのようなものかに触れておきたい。

## プログラミングができる人、できない人

どの分野でも見られることだと思うが、特にプログラミングにおいては「できる人」と「できない人」の差が激しく、生産性が10倍、100倍と桁で違うことも珍しくない。ここで「生産性」という言葉を使ったが、プログラミングにおける生産性を定量的に定義することは難しい。プログラムの生産性は、例えば(よくダメな組織で行われているように)一日に入力したプログラムの総行数で測ることはできない。プログラムが「できる人」は、別にキー入力が速いわけではない。また、プログラムに必要な知識が全て頭に入っているわけでもなく、よく構文を忘れて検索していたりする。では、「できる人」と「できない人」ではどこで一番差が出るか。個人的な経験では、それはデバッグの時間だと思われる。「できる人」は、作業時間のほとんどを純粋な開発に使っているが、逆に「できない人」は作業時間のほとんどデバッグに費やしている。開発しているコードが大きくなればなるほど、開発期間が長くなるほどその差は開き、「できない人」は、デバッグだけで一日が終わってしまった、といったことが起きる。

デバッグとは、プログラムに入ったバグを取り除く作業だ。バグとは、プログラムが意図しない動作をする、その原因である。例えば、あなたが卒業研究用の数値計算コードを書いていて、エネルギーが保存されなくなっていることに気が付いたとする。エネルギーが保存すべき系を計算しているので、このコードはどこか間違っている。したがって、その全ての出力結果は信頼することができず、それを修正するまでは他の全ての作業がストップする。デバッグの開始である。あなたはコードを最初から最後まで詳細に調べ、どこで間違っているかを考える。一度見ただけでは問題は見つからず、なんどもなんども読み返す。最近、どんな変更をしたかを思い返し、そこを元に戻してみるが、まだおかしい。そのうち、修正していなかったところを変な風に直してしまい、だんだん収拾がつかなくなる。そうしてずっとコードの中をさまよった結果、ついにバグの原因を発見。コードに機能追加する際にif文を追加したのだが、その条件漏れだった。外を見ると夜が白みはじめている。12時間以上集中していたようだ。今日もよくがんばった。明日からまた開発を続けよう・・・

プログラミングに慣れていない人は、往々にしてこのようにデバッグに時間をかけがちである。デバッグは絶対に行わなければならない作業であり、達成条件も明確であることから、デバッグをしていると「仕事をしている」という実感が強いのだが、実際には自分でいれたバグを自分でとっているだけであり、プロジェクトとしては何ら前に進んでいない。あなたが研究室で12時間ぶっ続けでデバッグをしている間、別の人は4時間くらいかけて新機能を実装し、2時間くらいかけてその結果を確認、うまくいってそうなのでスパコンにジョブを投げ、気になっていたドラマの続きを見ながらご飯を食べ、ゆっくりお風呂に入ってさっさと寝ているかもしれない。外から見て「がんばっている」ように見えるのは12時間ぶっ続けデバッグの人だが、もちろん実際に研究が進んでいるのは後者の人だ。

さて、この差はどこから来たか。当然のことながら、「できる人」はそもそもバグを入れにくいコードの組み方をしている。また、不具合を見つけた時、どこにバグがあるか発見しやすいように、プログラムを疎結合に作ってあることが多い。こういった「バグに強いコードを作る技術」には、長い歴史があるが、それについては本講義の対象とはしない。本講義では、バージョン管理システムの一つであるGitを扱う。もしバージョン管理システムを使っていたら、デバッグがどんな様子になるか見てみよう。

TODO: 比較の絵を追加

Git/GitHubを使ってコードを開発している人が、やはり卒業研究用の数値計算コードを書いていて、エネルギーが保存されなくなっていることに気が付いたとする。エネルギーが保存する系を計算しているのだから、これはバグだ。この人は慌てずに、GitHubでissueを立てる[^terminology]。どのような入力を与えたら、どんな出力が出たか。期待する出力はどういうものか。そして、issueに対応して新しいブランチを作る。「できない人」はバグを見つけたらコードを読み返して、頭の中で仮想実行することでバグを発見しようとした。しかし、バージョン管理している人はそういうことをしない。まず、バージョン管理システムで十分に古いバージョンを引っ張り出し、同じシミュレーションを走らせる。すると、エネルギーは保存している。昔はバグっていなかったが、現在はバグっている、つまり、どこかでバグが入ったはずだ。それを確認した後、コードが「バグっているか」「バグっていないか」を機械的に判定するスクリプトを書く。今回の例なら、ある入力からシミュレーションして、エネルギーが一定の範囲内に収まっていればバグっていない。そこからはみ出せばバグっている、そのチェックスクリプトを書く。そんなスクリプトならものの5分もあれば書けるであろう。そして、おもむろに`git bisect`というコマンドをたたく。これは、バグ判定テストスクリプトを食わせると、どこでそのスクリプトが初めて失敗するかを探索してくれるコマンドだ。これにより、あるコミットまではバグっておらず、次のコミットでバグった、ということがわかる。次に`git diff`コマンドにより、その二つのコミットの差分を見る。機能追加のために`if`文を追加したところだ。ここで初めて頭を使う。この`if`文の条件にどんな内容が来たかを確認し、条件漏れがあることに気づく。そこを修正し、テストスクリプトが通ることを確認。コミットして、開発ブランチにマージする。GitHubにpushすると、先ほど作ったissueが閉じられて、デバッグ完了である。ここまで、せいぜい30分かかるかどうか。

ここで「GitやGitHubなどのツールを使うとデバッグ時間が短くなる」と言いたいわけでは**ない**ことを強調しておきたい。「できる人」の例では、デバッグで徹底して頭を使っていない。なるべく機械的にバグの範囲を時間的、空間的に狭めていき、最後の最後でちょっと頭を使うだけでデバッグを完了している。ここでGitはこの方針のデバッグを補助するためのツールとして使われており、おそらく、Gitを使っていなかったとしても似たような時間でデバッグを完了していたであろう。もちろんGitなどのツールは便利であり、うまく使えばデバッグ時間を飛躍的短くすることができる可能性がある。しかし、Gitは、あくまで何かしらの開発スタイルを支援するためのツールなのであって、そのような開発スタイルが身についていない人が形だけ導入しても効果は得られない。本講義では、ツールとしてのGitの使い方そのものより、なぜそのコマンドがあるか、どのような場合に使うか等の「思想」を学んでほしい。

[^terminology:] issueやブランチ等、Git/GitHubの用語が出てくるが、これらについては後ほど説明するので、いまは雰囲気だけ感じとれれば良い。

## バージョン管理システムとは

プログラミングに限らず、多くの知的生産活動は「一度作ったら終わり」ではなく、継続的な修正が必要となる。例えば、卒業論文を書くとする。一度書いたら終わりではなく、先生にみせて、真っ赤にされて返ってきて、さらに修正して、ということを繰り返すであろう。また、情報系の学科だったり、それ以外でも数値計算系の研究室や電子機器を制御する研究室に所属した場合は日常的にプログラムを書くことになるだろう。それらのプログラムも、使っているうちに機能を追加したくなったり、見つけたバグを修正したくなったりするであろう。明示的に気にしていなくても、何かを修正、保存するたびに、そのドキュメントやプログラムの「バージョン」は上がっていくことになる。そのドキュメントやプログラムを複数人で修正したり、一人でも複数の場所で開発していたりすると、「バージョン」の管理が難しくなる。例えば家で修正した最新版の卒論ではなく、大学のPCに入っていたちょっと古いバージョンのものを先生に渡してしまい、朱入れされて返ってきたものを見て、古い奴を渡したことに気が付いて気まずい思いをしたり、なんてことがあり得る(実話)。また、手元のPCで開発していたコードをスパコンに持って行ってそこで動くように修正し、スパコンで実行中に手元のコードを修正して、またスパコンに持っていったら、スパコン上で行った修正を上書きしてしまった、なんてことも起きる(実話)。こういった悲劇(喜劇)を防ぐのがバージョン管理システム(Version Control System, VCS)である。

### 歴史

簡単にバージョン管理システムの歴史を見てみよう。おおざっぱに言えば、バージョン管理システムはローカル型、中央集権クライアント―サーバ型、そして分散型へと進化していった。

世界初のバージョン管理システムはSource Code Control System (SCCS)であり、1972年、IBMのSystem/370向けに開発され、後にPDP-11上に移植された。次いで、1982年にRevision Control System (RCS)というシステムが開発された。RCSはファイル単位でバージョンの管理を行い、プロジェクトという概念も無かった。また、ファイルを修正する際にロックをかけるのが特徴で、誰かが作業している場合、他の人が作業することはできなかった。ここまでのシステムはローカルに管理用のディレクトリを置いてバージョン履歴をそこに保存する形式(ローカル型)であったが、1986年に作られたConcurrent Versions System (CVS)から、クライアント―サーバ型となった。CVSサーバはプロジェクトの全履歴を保存しており、クライアントはサーバに接続して任意のバージョンを取り出すことができ、修正したらサーバにその変更を保存することができる。CVSは、RCSのフロントエンドとして構築されており、キーワード展開や、コマンド名など多くの機能がRCSに由来している。CVSは長い間、バージョン管理システムのデファクトスタンダードとして広く使われていたが、ファイル名を変更すると履歴が失われてしまったり、バージョン管理がファイルごとであるために「全体をこの日のバージョンに戻したい」といった操作が面倒であるなど、不満も多かった。それらの不便を解消し、CVSの置き換えを目指して作られたのがSubversionである。Subversionはバージョンがプロジェクト(リポジトリ)単位であり、プロジェクトに含まれるファイルを一つでも更新すると、全体のバージョンがあがる。したがって、「この日のバージョンが欲しい」といったことが容易にできる。また、履歴を差分で保存するため、長い間開発していてもファイル容量を圧迫しづらいように工夫されていた。Subversionはその目的通りにCVSを置き換え、最も使われるバージョン管理システムとなった。


* 歴史(いるかな？)
* 種類
  * 中央管理型
  * 分散型
* 多人数開発
* 何ができるか