# バージョン管理とは

## なぜバージョン管理が必要か

ソフトウェア開発の歴史は古く、その開発手法も日進月歩である。ソフトウェア開発の歴史は、バグとの戦いの歴史でもあった。一人で開発していてもバグは入るが、大勢で開発を進めればより一層バグが入りやすくなり、ソフトウェア開発そのものよりも、バグの修正に時間を取られてしまう。また、多人数で開発をすすめると、誰がどこを修正したかがわかりにくくなる。例えば、複数の人が一つのWordファイルを回り持ちで修正し、「仕様書_佐藤修正_吉本追記.docx」というファイルと「仕様書_最終版_田中追記.docx」のどちらが最新版かわからなくなる、といったことが起きる。このような背景の中、バージョン管理システムは生まれた。

バージョン管理システムは、その名の通りファイルのバージョンを管理するためのツールである。いつ、誰が、どこを修正したかを記録し、必要とあれば古いバージョンを参照することができる。また、複数人が同じファイルを同時に編集してしまった場合に、その両方の変更を取り込む支援を行う。現在、バージョン管理システムを使わないソフトウェア開発は考えられず、プログラムの開発をともなう部署は、どのツールを使うかはともかく、なんらかのバージョン管理システムを採用しているものと思われる[^1]。

[^1]: もしバージョン管理システムを採用しておらず、日付やエクセルなどでバージョン管理をしている会社に入ってしまったらダッシュで逃げること。

本講義ではバージョン管理システムとしてGitを採用し、その使い方を学ぶが、その前にソフトウェア開発とはどのようなものかに触れておきたい。

## プログラミングができる人、できない人

どの分野でも見られることだと思うが、特にプログラミングにおいては「できる人」と「できない人」の差が激しいく、生産性が10倍、100倍と桁で違うことも珍しくない。ここで「生産性」という言葉を使ったが、プログラミングにおける生産性を定量的に定義することは難しい。プログラムの生産性は、例えば(よくダメな組織で行われているように)一日に入力したプログラムの総行数で測ることはできない。プログラムが「できる人」は、別にキー入力が速いわけではない。また、プログラムに必要な知識が全て頭に入っているわけでもなく、よく構文を忘れて検索していたりする。では、「できる人」と「できない人」ではどこで一番差が出るか。個人的な経験では、それはデバッグの時間だと思われる。「できる人」は、作業時間のほとんどを純粋な開発に使っているが、逆に「できない人」は作業時間のほとんどデバッグに費やしている。開発しているコードが大きくなればなるほど、開発期間が長くなるほどその差は開き、「できない人」は、デバッグだけで一日が終わってしまった、といったことが起きる。

デバッグとは、プログラムに入ったバグを取り除く作業だ。バグとは、プログラムが意図しない動作をする、その原因である。例えば、あなたが卒業研究用の数値計算コードを書いていて、エネルギーが保存されなくなっていることに気が付いたとする。エネルギーが保存すべき系を計算しているので、このコードはどこか間違っている。したがって、その全ての出力結果は信頼することができず、それを修正するまでは他の全ての作業がストップする。デバッグの開始である。あなたはコードを最初から最後まで詳細に調べ、どこで間違っているかを考える。一度見ただけでは問題は見つからず、なんどもなんども読み返す。最近、どんな変更をしたかを思い返し、そこを元に戻してみるが、まだおかしい。そのうち、修正していなかったところを変な風に直してしまい、だんだん収拾がつかなくなる。そうしてずっとコードの中をさまよった結果、ついにバグの原因を発見。コードに機能追加する際にif文を追加したのだが、その条件漏れだった。外を見ると夜が白みはじめている。12時間以上集中していたようだ。今日もよくがんばった。明日からまた開発を続けよう・・・

プログラミングに慣れていない人は、往々にしてこのようにデバッグに時間をかけがちである。デバッグは絶対に行わなければならない作業であり、達成条件も明確であることから、デバッグをしていると「仕事をしている」という実感が強いのだが、実際には自分でいれたバグを自分でとっているだけであり、プロジェクトとしては何ら前に進んでいない。あなたが研究室で12時間ぶっ続けでデバッグをしている間、別の人は4時間くらいかけて新機能を実装し、2時間くらいかけてその結果を確認、うまくいってそうなのでスパコンにジョブを投げ、気になっていたドラマの続きを見ながらご飯を食べ、ゆっくりお風呂に入ってさっさと寝ているかもしれない。外から見て「がんばっている」ように見えるのは12時間ぶっ続けデバッグの人だが、もちろん実際に研究が進んでいるのは後者の人だ。

さて、この差はどこから来たか。当然のことながら、「できる人」はそもそもバグを入れにくいコードの組み方をしている。また、不具合を見つけた時、どこにバグがあるか発見しやすいように、プログラムを疎結合に作ってあることが多い。こういった「バグに強いコードを作る技術」には、長い歴史があるが、それについては本講義の対象とはしない。本講義では、バージョン管理システムの一つであるGitを扱う。もしバージョン管理システムを使っていたら、デバッグがどんな様子になるか見てみよう。

Git/GitHubを使ってコードを開発している人が、やはり卒業研究用の数値計算コードを書いていて、エネルギーが保存されなくなっていることに気が付いたとする。エネルギーが保存する系を計算しているのだから、これはバグだ。この人は慌てずに、GitHubでissueを立てる[^1]。どのような入力を与えたら、どんな出力が出たか。期待する出力はどういうものか。そして、issueに対応して新しいブランチを作る。「できない人」はバグを見つけたらコードを読み返して、頭の中で仮想実行することでバグを発見しようとした。しかし、バージョン管理している人はそういうことをしない。まず、バージョン管理システムで十分に古いバージョンを引っ張り出し、同じシミュレーションを走らせる。すると、エネルギーは保存している。昔はバグっていなかったが、現在はバグっている、つまり、どこかでバグが入ったはずだ。それを確認した後、コードが「バグっているか」「バグっていないか」を機械的に判定するスクリプトを書く。今回の例なら、ある入力からシミュレーションして、エネルギーが一定の範囲内に収まっていればバグっていない。そこからはみ出せばバグっている、そのチェックスクリプトを書く。そんなスクリプトならものの5分もあれば書けるであろう。そして、おもむろに`git bisect`というコマンドをたたく。これは、バグ判定テストスクリプトを食わせると、どこでそのスクリプトが初めて失敗するかを探索してくれるコマンドだ。これにより、あるコミットまではバグっておらず、次のコミットでバグった、ということがわかる。次に`git diff`コマンドにより、その二つのコミットの差分を見る。機能追加のために`if`文を追加したところだ。ここで初めて頭を使う。この`if`文の条件にどんな内容が来たかを確認し、条件漏れがあることに気づく。そこを修正し、テストスクリプトが通ることを確認。コミットして、開発ブランチにマージする。GitHubにpushすると、先ほど作ったissueが閉じられて、デバッグ完了である。ここまで、せいぜい30分かかるかどうか。

ここで「GitやGitHubなどのツールを使うとデバッグ時間が短くなる」と言いたいわけでは**ない**ことを強調しておきたい。「できる人」の例では、デバッグで徹底して頭を使っていない。なるべく機械的にバグの範囲を時間的、空間的に狭めていき、最後の最後でちょっと頭を使うだけでデバッグを完了している。ここでGitはこの方針のデバッグを補助するためのツールとして使われており、おそらく、Gitを使っていなかったとしても似たような時間でデバッグを完了していたであろう。もちろんGitなどのツールは便利であり、うまく使えばデバッグ時間を飛躍的短くすることができる可能性がある。しかし、Gitは、あくまで何かしらの開発スタイルを支援するためのツールなのであって、そのような開発スタイルが身についていない人が形だけ導入しても効果は得られない。本講義では、ツールとしてのGitの使い方そのものより、なぜそのコマンドがあるか、どのような場合に使うか等の「思想」を学んでほしい。

[^1:] issueやブランチ等、Git/GitHubの用語が出てくるが、これらについては後ほど説明するので、いまは雰囲気だけ感じとれれば良い。

## バージョン管理システムとは

* 歴史(いるかな？)
* 種類
  * 中央管理型
  * 分散型
* 多人数開発
* 何ができるか